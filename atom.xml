<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Just Be Unreserved!</title>
  <subtitle>学无止境。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.easydone.cn/"/>
  <updated>2019-01-05T14:21:47.784Z</updated>
  <id>http://www.easydone.cn/</id>
  
  <author>
    <name>Ailurus</name>
    <email>woshiliangzhitao@gmail.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>2019-01-05-说说近况</title>
    <link href="http://www.easydone.cn/2019/01/05/"/>
    <id>http://www.easydone.cn/2019/01/05/</id>
    <published>2019-01-05T14:06:30.000Z</published>
    <updated>2019-01-05T14:21:47.784Z</updated>
    
    <content type="html">&lt;p&gt;最近过得不是很开心，因为工作的事。&lt;/p&gt;
&lt;p&gt;记得从口袋离职的时候，虎哥就告诉过我，以后讲话要注意分寸，我媳妇儿也不止一次也批评过我，做人不够圆滑，就连现在的室友也说我说话太直接…每次我也都自我批评，然而事到如今，还是因此付出了代价。&lt;/p&gt;
&lt;p&gt;想要活成令狐冲，偏偏只能做莫大。&lt;/p&gt;
&lt;p&gt;算了，不说了…&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;最近过得不是很开心，因为工作的事。&lt;/p&gt;
&lt;p&gt;记得从口袋离职的时候，虎哥就告诉过我，以后讲话要注意分寸，我媳妇儿也不止一次也批评过我，做人不够圆滑，就连现在的室友也说我说话太直接…每次我也都自我批评，然而事到如今，还是因此付出了代价。&lt;/p&gt;
&lt;p&gt;想要活成令狐冲，偏偏
    
    </summary>
    
      <category term="随笔" scheme="http://www.easydone.cn/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="家庭" scheme="http://www.easydone.cn/tags/%E5%AE%B6%E5%BA%AD/"/>
    
      <category term="工作" scheme="http://www.easydone.cn/tags/%E5%B7%A5%E4%BD%9C/"/>
    
      <category term="近况" scheme="http://www.easydone.cn/tags/%E8%BF%91%E5%86%B5/"/>
    
  </entry>
  
  <entry>
    <title>Flutter之我见</title>
    <link href="http://www.easydone.cn/2018/06/29/"/>
    <id>http://www.easydone.cn/2018/06/29/</id>
    <published>2018-06-29T15:58:31.000Z</published>
    <updated>2018-06-29T16:14:15.257Z</updated>
    
    <content type="html">&lt;p&gt;这两天花了点业余时间，大致了解了一下，尝试写了几段代码。对于原理什么的还是一窍不通，如果想要深入了解，推荐看看闲鱼的分享，我只是对于语法和 UI 写法有一点简单的认识。说的不对，还请大伙轻喷。相互学习，共同进步。&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;我对 JS 也不熟，只是简单了解过 JSX、Rax 和 Weex 相关的一些东西。刚开始写 Flutter 的时候，由于我是做 Native 开发的，所以第一感觉就是居然跟 JSX 有点像，我觉着，如果真的是对 JS 很熟悉的前端开发人员要做 Flutter 开发的话，应该会很快上手。不过比较恶心的一点是控件嵌套太多了，比起 Rax、React 那种差太远了，更别提跟原生 Native 开发的 XML 布局相比了。一眼望去，全是花括弧和圆括弧，这个巨大的硬伤估计会让很多人敬而远之。&lt;/p&gt;
&lt;p&gt;Flutter 有不少特性估计会让 Android 原生 Native 开发人员增加不少好感。天生对 Material 的良好支持；而且像 Native 开发那样内置很多 style，可以直接调用，而不需要像 Rax 和 React 那样要自己写一大堆 CSS；还有就是 IDE 支持，Android Studio 安装插件就可以，虽然 Weex 也可以用 WebStorm，但是单就语法提示这一项，Flutter 就比 Weex 更能吸粉。&lt;/p&gt;
&lt;p&gt;Flutter 现在的致命伤是跟 Weex 一样，依赖支持库真的比 Native 开发差的太多太多了，而且依赖管理和 DSL 可能要落后 Gradle 三四年，当然，这可能也是因为 Gradle 太先进了。这一点，志在取代 Java 的 Kotlin，目标可能会更容易现实。&lt;/p&gt;
&lt;p&gt;还有一点，我严重怀疑大多数人根本没实际尝试过，就随便说 Flutter 的性能接近原生 Native。我自己在 Sony Z3+（15年旗舰机）上实际测试得出的数据是，debug 版本，一个 item 只有一个英文单词的 ListView， 安装后前几次启动起码要白屏 1 秒钟才能显示出来列表数据，而且前几次滑动用 GameBench 测得的帧率没有任何一次超过 40 帧的；而同样场景的 Native 代码，都是瞬间启动，滑动也都是满帧。我丝毫不怀疑 release 版本，它会有更好的表现，但是至少同等条件下，并不像那么多营销文说的那样达到了 Native 开发的性能和体验。我翻了下一下 GitHub 的 issue，有不少人都吐槽滑动有明显卡顿的。还有路由跳转返回的时候，卡顿也很明显。不过，我听一个技术非常非常厉害的朋友讲，虽然 Flutter 滑动帧率确实不高，但是动画表现非常不错。现在还只是 1.0，相信以后会慢慢优化好的。&lt;/p&gt;
&lt;p&gt;不管怎样，我都觉着跨平台开发会是以后一个趋势。不管是 RN、Weex，还是 Flutter，作为技术人员都不应该排斥，前端技术的相互影响，相互促进，会对人的思维和习惯产生极大的正面作用。即便是为了混饭吃，这也是一个不错的方向。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;这两天花了点业余时间，大致了解了一下，尝试写了几段代码。对于原理什么的还是一窍不通，如果想要深入了解，推荐看看闲鱼的分享，我只是对于语法和 UI 写法有一点简单的认识。说的不对，还请大伙轻喷。相互学习，共同进步。
    
    </summary>
    
    
      <category term="Android" scheme="http://www.easydone.cn/tags/Android/"/>
    
      <category term="Flutter" scheme="http://www.easydone.cn/tags/Flutter/"/>
    
  </entry>
  
  <entry>
    <title>使用 repo 组织 Android 工程</title>
    <link href="http://www.easydone.cn/2018/01/01/"/>
    <id>http://www.easydone.cn/2018/01/01/</id>
    <published>2018-01-01T11:02:17.000Z</published>
    <updated>2018-01-01T12:04:41.421Z</updated>
    
    <content type="html">&lt;p&gt;关于 Repo 的文章，我之前写过一篇：&lt;a href=&quot;https://www.easydone.cn/2017/04/24/&quot;&gt;Repo VS Submodule&lt;/a&gt;，不过只是讲了 Repo 和 Submodule 的区别，以及 Repo 使用过程中的一些注意事项，然而在具体的项目里的所谓的最佳实践却并没有涉及。这篇文章，我想谈一下关于实践的内容，当然，是不是“最佳”实践，我也不敢妄言，每个人能有自己的理解，如果我能够抛砖引玉，引申出其他人更优的实践方案，那就很好了。&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;工程结构的变化&quot;&gt;&lt;a href=&quot;#工程结构的变化&quot; class=&quot;headerlink&quot; title=&quot;工程结构的变化&quot;&gt;&lt;/a&gt;工程结构的变化&lt;/h2&gt;&lt;p&gt;项目达到的一定的阶段，业务的组件化是必经之路，这一点毋庸置疑。如今，已经很少有项目还是一个子工程了，对于 Android 项目来讲，一般也都是基于 Gradle 的多 project 项目。Android Studio 默认创建项目，也是 multi-project 的形式，大致可能如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;根目录下一个 setting.gradle 文件和 build.gradle 文件，setting.gradle 里配置此项目包含的子项目，build.gradle 里包含整个工程所需要的 gradle 插件和子项目依赖所需的仓库地址；&lt;/li&gt;
&lt;li&gt;根目录下有一个或者多个子 module，这些子 module 就是整个工程的子项目，在子项目里，有自己独立的 build.gradle 文件，里面包含了此子项目所需的各种配置；&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&quot;http://7x2wvb.com1.z0.glb.clouddn.com/2018-01-01_17-54-35.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;center&gt;host、library1、library2、library3、library4 是工程里的子项目&lt;/center&gt;

&lt;p&gt;今天我们要讲 repo，那如果把我们的工程结构进行 repo 改造之后，会是什么样呢？实际上，还是跟上面讲的一模一样。我们首先要明确 repo 只是一个版本控制管理工具，因此项目在形式上跟之前是没有区别的。但是从版本控制的角度讲，区别就大了。以前不管有多少个子项目，我们所有的代码都是在一个 git 仓库里，而 repo 改造之后，我们的宿主项目和其他所有的子项目都分别是一个独立的 git 仓库了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7x2wvb.com1.z0.glb.clouddn.com/2018-01-01_17-56-49.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;从上面的目录树截图，我们可以看到，相对于我们常见的工程结构，在项目的 rootProject 同一级多了一个 .repo 目录，因此这里就出现了第一个实践经验：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果是一个 repo 工程的话，我们最好新建一个空目录，然后在这个空目录里 init 我们的 repo 工程。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在 repo 里，每个子项目都是一个独立的 git 仓库，而且所有的子项目都是平级的，不存在任何从属关系，只是对一个 App 来讲，子 module 项目需要依附于宿主 module 才能打包安装运行。因此，这里又出现了第二个实践经验：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;我们可以把工程的 rootProject 和宿主 module 合并起来作为一个 git 仓库，这也是我们打包运行 App 的&lt;strong&gt;最小单元&lt;/strong&gt;。而其他的子 module，也完全可以像宿主 module 一样，单独导入 IDE 进行开发，编译打包成 aar。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;repo 是通过 .repo/manifest/default.xml 文件来管理项目的，xml 里每个 project 节点代表一个项目，管理多少个项目，就有多少个 project 节点。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7x2wvb.com1.z0.glb.clouddn.com/2018-01-01_18-29-16.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;然而我们看到这个 xml 文件是在 .repo/manifest 目录的，而我们导入 IDE 的是 projects 这个目录，这样在 IDE 里我们就看不到 .repo 目录，这对我们管理子项目是非常不方便的，因此这里又出现一个实践经验：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在主工程目录里创建一个 .repo/manifest/default.xml 的软链接，default.xml 初始化完毕之后（默认只有最小单元不被注释掉，其他所有的子 module 都会被注释掉），将其加入 .gitignore 里，这样我们本地开发就可以随意更改这个文件，同时也不会影响到其他人。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;主-module-与子-module-的互动&quot;&gt;&lt;a href=&quot;#主-module-与子-module-的互动&quot; class=&quot;headerlink&quot; title=&quot;主 module 与子 module 的互动&quot;&gt;&lt;/a&gt;主 module 与子 module 的互动&lt;/h2&gt;&lt;p&gt;我们拆分 module 的目的是什么呢？&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;厘清业务职责边界，避免模块间过多的相互影响；&lt;/li&gt;
&lt;li&gt;业务模块独立开发编译打包，提高并行开发效率；&lt;/li&gt;
&lt;li&gt;业务模块独立发布到 maven 上维护，宿主引用 maven 上的依赖，提高编译速度。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;既然业务 module 要独立开发编译，那将这个模块作为一个单独的 git 仓库，一定是要比跟其他 module 杂糅到一起，效率要高很多，但是独立出来，打出来一个 aar，也并没有什么卵用，还需要上传到 maven 上，然后宿主 module 再去引用打包才可以。这就牵涉到主 module 与子 module 的互动问题，怎样互动效率才最高呢？基于 repo，我们就可以这样做：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;将 repo 里打包运行 App 的最小单元（即 rootProject 和宿主 module）导入 IDE；&lt;/li&gt;
&lt;li&gt;修改我们创建的软链接，如果我们要开发 library1 模块，那就将 default.xml 里 library1 这个模块的注释放开；&lt;/li&gt;
&lt;li&gt;在 rootProject 目录里，执行 &lt;code&gt;repo sync library1&lt;/code&gt; 即可检出 library1 的代码；&lt;/li&gt;
&lt;li&gt;在宿主 module 里 &lt;code&gt;implementation project(&amp;#39;:library1&amp;#39;) //compile project(&amp;#39;:library1&amp;#39;)&lt;/code&gt;。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这样比起将 library1 单独导入到一个 IDE，然后宿主 module 通过 maven 依赖还有一个好处，就是调试起来会更方便了，无需每次修改一点代码，就要打包上传 maven。&lt;/p&gt;
&lt;p&gt;这是日常业务开发层面的问题，但是我们只是解决了我们要开发的 module 与宿主 module 之间的互动问题，那那些不是我们当前要开发的模块怎么办呢？当然是直接使用 maven 上的了。但是这样显然就太麻烦了，每次都要手动改一堆东西，所幸这里我们可以通过 gradle 脚本来让整个过程自动化。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;我们可以在宿主 module 的 gradle.properties 里列出来宿主 module 依赖的各个 module 打包出来的 aar 的版本号：&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;library1=1.0.0-SANPSHOT&amp;#10;library2=1.0.0-SANPSHOT&amp;#10;library3=1.0.0-SANPSHOT&amp;#10;library4=1.0.0-SANPSHOT&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;在宿主的 build.gradle 里我们可以这样去声明依赖：&lt;/p&gt;
&lt;figure class=&quot;highlight groovy&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; moduleVersions = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Properties()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; moduleVersionsFile = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; File(&lt;span class=&quot;string&quot;&gt;&quot;$&amp;#123;project.projectDir&amp;#125;/gradle.properties&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;moduleVersions.load(moduleVersionsFile.newDataInputStream())&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;dependencies &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; projects = moduleVersions.stringPropertyNames()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    rootProject.subprojects.each &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (it.name != &lt;span class=&quot;string&quot;&gt;&#39;host&#39;&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            implementation it&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            projects.remove(it.name)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    projects.each &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;//为了方便引用，这里要求我们上传到 maven 的各模块的包遵循一定的规则，groupid 需要保持一致，&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// artifactid 最好是以子 module 的 project.name 来命名，如果不是这样的规则，就需要自己修改 gradle 脚本啦&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        implementation &lt;span class=&quot;string&quot;&gt;&quot;me.ailurus.repo:$&amp;#123;it&amp;#125;:$&amp;#123;moduleVersions.getProperty(it)&amp;#125;&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这样就保证了本地代码里没有子 module，可以自动引用 maven 上的 module 依赖。&lt;/p&gt;
&lt;h2 id=&quot;工程动态添加子项目&quot;&gt;&lt;a href=&quot;#工程动态添加子项目&quot; class=&quot;headerlink&quot; title=&quot;工程动态添加子项目&quot;&gt;&lt;/a&gt;工程动态添加子项目&lt;/h2&gt;&lt;p&gt;其实关于 repo 的实践，上面的部分基本已经讲完了，不过既然是实践经验，在这样的工程结构，附带的还有一点可以优化。&lt;/p&gt;
&lt;p&gt;我们都知道，在 gradle 工程里，由于 gradle 的生命周期的存在，任何一个子项目的编译，都要经过&lt;strong&gt;所有子项目&lt;/strong&gt;的 configuration 阶段，如果有什么依赖的 maven 坐标定位缓慢或者依赖本身下载缓慢，这个阶段将会非常耗时。因此要解决这个问题，最行之有效的手段就是减少子项目数量。那么问题又来了，我们总不能每次都手动去注释 setting.gradle 的 include 的子项目吧。&lt;/p&gt;
&lt;p&gt;当然不！有了 repo，这个问题就简单了，我们可以通过脚本，去解析我们放在 rootProject 目录下的 xml 软链接文件，读取到的 project 节点就是我们要 include 的子项目（当然，最小运行单元最好还是单独 include 进来）。&lt;/p&gt;
&lt;figure class=&quot;highlight groovy&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;include &lt;span class=&quot;string&quot;&gt;&#39;:host&#39;&lt;/span&gt;&lt;span class=&quot;comment&quot;&gt;//最小运行单元&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; manifest = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; XmlParser().parse(&lt;span class=&quot;string&quot;&gt;&quot;$&amp;#123;rootProject.projectDir&amp;#125;/default.xml&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;manifest.project.each &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    it.attributes().each &amp;#123; k, v -&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (k == &lt;span class=&quot;string&quot;&gt;&#39;path&#39;&lt;/span&gt; &amp;amp;&amp;amp; !v.contains(&lt;span class=&quot;string&quot;&gt;&#39;host&#39;&lt;/span&gt;)) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            include v.replace(&lt;span class=&quot;string&quot;&gt;&#39;/&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;:&#39;&lt;/span&gt;) - rootProject.name&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这就是 gradle 工程动态添加子项目。&lt;/p&gt;
&lt;p&gt;在&lt;a href=&quot;https://github.com/liangzhitao/repo-manifest&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;这里&lt;/a&gt;可以下载代码演示查看。&lt;/p&gt;
&lt;h2 id=&quot;结语&quot;&gt;&lt;a href=&quot;#结语&quot; class=&quot;headerlink&quot; title=&quot;结语&quot;&gt;&lt;/a&gt;结语&lt;/h2&gt;&lt;p&gt;以上就是关于 repo 在 Android 工程里全部的实践经验。我们可以看到，这完全不是从无到有的颠覆性的开发方式创新，而是针对现有工程的简单改造优化，而这些简单的优化带来的收益是非常显著的。当然，这也只是一家之言，也欢迎有兴趣的朋友多多尝试，以寻求更优更好的开发方式。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;关于 Repo 的文章，我之前写过一篇：&lt;a href=&quot;https://www.easydone.cn/2017/04/24/&quot;&gt;Repo VS Submodule&lt;/a&gt;，不过只是讲了 Repo 和 Submodule 的区别，以及 Repo 使用过程中的一些注意事项，然而在具体的项目里的所谓的最佳实践却并没有涉及。这篇文章，我想谈一下关于实践的内容，当然，是不是“最佳”实践，我也不敢妄言，每个人能有自己的理解，如果我能够抛砖引玉，引申出其他人更优的实践方案，那就很好了。
    
    </summary>
    
      <category term="Android" scheme="http://www.easydone.cn/categories/Android/"/>
    
    
      <category term="Android" scheme="http://www.easydone.cn/tags/Android/"/>
    
      <category term="Gradle" scheme="http://www.easydone.cn/tags/Gradle/"/>
    
      <category term="repo" scheme="http://www.easydone.cn/tags/repo/"/>
    
  </entry>
  
  <entry>
    <title>在 Android Application 里 provided aar</title>
    <link href="http://www.easydone.cn/2017/11/07/"/>
    <id>http://www.easydone.cn/2017/11/07/</id>
    <published>2017-11-07T13:44:18.000Z</published>
    <updated>2017-11-15T15:54:23.274Z</updated>
    
    <content type="html">&lt;p&gt;首先得声明一下，其实 &lt;code&gt;provided aar&lt;/code&gt; 这样的需求场景非常少。在 &lt;code&gt;com.android.library&lt;/code&gt; 里可以直接 &lt;code&gt;provided aar&lt;/code&gt;，因此这样的需求只会在 &lt;code&gt;com.android.application&lt;/code&gt; 里存在。同时还得再声明一下，这里说的 &lt;code&gt;provided&lt;/code&gt; 一个 &lt;code&gt;aar&lt;/code&gt;，是只引用 &lt;code&gt;aar&lt;/code&gt; 里的类，而 &lt;code&gt;aar&lt;/code&gt; 里的资源还是没办法引用的。&lt;/p&gt;
&lt;p&gt;而完成插件化之后的微店，就恰恰对这样的需求非常强烈。一个 &lt;code&gt;application module&lt;/code&gt; 里 &lt;code&gt;compile&lt;/code&gt; 了一个&lt;code&gt;aar&lt;/code&gt;，在其他 &lt;code&gt;application moduel&lt;/code&gt; 里也想用这个 &lt;code&gt;aar&lt;/code&gt; 里的类，而作者在发布 &lt;code&gt;aar&lt;/code&gt; 的时候，并没有发布对应的 &lt;code&gt;jar&lt;/code&gt;，这时候我们的做法往往是手动地解压出来 &lt;code&gt;aar&lt;/code&gt; 里的 &lt;code&gt;classes.jar&lt;/code&gt;，然后再在 &lt;code&gt;dependencies&lt;/code&gt; 里添加这个 &lt;code&gt;classes.jar&lt;/code&gt; 的 &lt;code&gt;provided&lt;/code&gt; 依赖。看上去很简单嘛，可问题是遇到一个就要这样做一次，这就好麻烦了。那么有没有一种纯自动的方式去做这个事情呢？这篇文章讲的就是这个事情。&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;需要解决的问题&quot;&gt;&lt;a href=&quot;#需要解决的问题&quot; class=&quot;headerlink&quot; title=&quot;需要解决的问题&quot;&gt;&lt;/a&gt;需要解决的问题&lt;/h3&gt;&lt;p&gt;首先，我们有必要把这个问题给拆解一下，看上去貌似只是一个解压一个 &lt;code&gt;aar&lt;/code&gt;（其实就是一个 zip 压缩包），然后拿到其中一个叫 &lt;code&gt;classes.jar&lt;/code&gt; 的 &lt;code&gt;entry&lt;/code&gt;。可真要将其完全融入整个项目构建，做成完全自动化的一个过程，其中可能遇到的难点可能远超你我的想象。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;直接 &lt;code&gt;provided&lt;/code&gt; 一个 &lt;code&gt;aar&lt;/code&gt;，在编译过程中是一定会抛出 &lt;code&gt;provided dependencies can only be jars&lt;/code&gt; 这样的异常的，那我们该&lt;strong&gt;如何添加&lt;/strong&gt;这样一个依赖？&lt;/li&gt;
&lt;li&gt;Gradle 是有离线编译功能的，如果本地缓存里已经有了这个依赖，那么开启离线编译模式，一样可以进行编译，我们 &lt;code&gt;provided aar&lt;/code&gt; 怎么做到&lt;strong&gt;离线编译&lt;/strong&gt;呢？&lt;/li&gt;
&lt;li&gt;上一个步骤里，我们说了要能够从本地缓存取依赖，那么都有&lt;strong&gt;哪些本地缓存&lt;/strong&gt;呢？&lt;/li&gt;
&lt;li&gt;如果不是离线编译，本地缓存没有这个依赖，需要从远程仓库下载这个依赖，我们又该&lt;strong&gt;怎么下载&lt;/strong&gt;这个远程依赖呢？&lt;/li&gt;
&lt;li&gt;与步骤3类似的问题，上一步骤里我们说要从远程仓库下载这个依赖，那么我们怎么知道从&lt;strong&gt;哪些远程仓库&lt;/strong&gt;下载依赖呢？&lt;/li&gt;
&lt;li&gt;我们需要将整个过程完美地嵌入到构建之中，那么应该&lt;strong&gt;怎样嵌入&lt;/strong&gt;到构建过程中的&lt;strong&gt;哪些步骤&lt;/strong&gt;之间呢？&lt;/li&gt;
&lt;li&gt;如何实现自动化从 &lt;code&gt;aar&lt;/code&gt; 里取到 &lt;code&gt;jar&lt;/code&gt;，同时又将 &lt;code&gt;jar&lt;/code&gt; 添加到依赖里去呢？&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这样分析下来，你会发现如果不是对 Android 构建有比较深入的了解，每一个问题都不是那么容易就能搞的定的。而实际上，真正把所有的问题都解决掉，只需要不到 150 行代码。下面，我们就一步步去解决这些问题。&lt;/p&gt;
&lt;h3 id=&quot;自定义-Android-Dependency-Scope&quot;&gt;&lt;a href=&quot;#自定义-Android-Dependency-Scope&quot; class=&quot;headerlink&quot; title=&quot;自定义 Android Dependency Scope&quot;&gt;&lt;/a&gt;自定义 Android Dependency Scope&lt;/h3&gt;&lt;p&gt;我们经常看到 &lt;code&gt;provided&lt;/code&gt; &lt;code&gt;compile&lt;/code&gt; &lt;code&gt;apt&lt;/code&gt; &lt;code&gt;annotationProcessor&lt;/code&gt; 这样的字符串，这其实就是 &lt;code&gt;Dependency Scope&lt;/code&gt;，也是 Gradle 项目的 &lt;code&gt;configuration&lt;/code&gt;，我们通过调用如下的 api，就可以获取这个 &lt;code&gt;configuration&lt;/code&gt; 包含哪些依赖：&lt;/p&gt;
&lt;figure class=&quot;highlight groovy&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;project.configurations.getByName(&lt;span class=&quot;string&quot;&gt;&#39;provided&#39;&lt;/span&gt;).dependencies &lt;span class=&quot;comment&quot;&gt;// provided/compile/apt...&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;我们既然要实现 &lt;code&gt;providedAar&lt;/code&gt;，现有的 &lt;code&gt;Dependency Scope&lt;/code&gt; 都不满足我们的需求，那就需要像 &lt;code&gt;apt&lt;/code&gt; 那样去自定义一个 &lt;code&gt;Scope&lt;/code&gt;，其实也就是 &lt;code&gt;configuration&lt;/code&gt; 了：&lt;/p&gt;
&lt;figure class=&quot;highlight groovy&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;project.configurations.create(&lt;span class=&quot;string&quot;&gt;&#39;providedAar&#39;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;当然，这都是一些 api 调用，没什么难度，我们只需要记住 &lt;code&gt;configuration&lt;/code&gt; &lt;code&gt;Dependency Scope&lt;/code&gt; 这些概念就可以了。&lt;/p&gt;
&lt;h3 id=&quot;加载缓存&quot;&gt;&lt;a href=&quot;#加载缓存&quot; class=&quot;headerlink&quot; title=&quot;加载缓存&quot;&gt;&lt;/a&gt;加载缓存&lt;/h3&gt;&lt;p&gt;Android 编译用到的缓存从以下几个地方去取：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;mavenLocal&lt;/code&gt; 和 &lt;code&gt;gradle.user.home&lt;/code&gt;（不要问我怎么知道的，看源码吧）；&lt;/li&gt;
&lt;li&gt;在 Android 项目里，还会有一个 SDK 目录下的仓库路径；&lt;/li&gt;
&lt;li&gt;旧版本的 Gradle Plugin 会从 &lt;code&gt;$buildDir/intermediates/exploded-aar&lt;/code&gt; （这是个临时路径，每次 clean 都会被清空）去读取，新版本会从 &lt;code&gt;$HOME/.android/build-cache&lt;/code&gt; （这不是临时路径，执行 clean 不会被清空）读取，当然，这个是有开关，可以选择是否开启的；&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;code&gt;mavenLocal&lt;/code&gt; 里的依赖的父目录路径大致是这样的：&lt;code&gt;~/.m2/repository/com/google/code/gson/gson/2.7&lt;/code&gt;，这路径下面就是具体的 &lt;code&gt;jar&lt;/code&gt; &lt;code&gt;aar&lt;/code&gt; &lt;code&gt;pom&lt;/code&gt; 等文件。根据这些现象，我们再去看源码，就很容易会发现 &lt;code&gt;mavenLocal&lt;/code&gt; 里的依赖父目录路径遵循以下规律（&lt;code&gt;mavenLocal&lt;/code&gt; 路径，与依赖的 &lt;code&gt;groupId&lt;/code&gt; &lt;code&gt;artifactId&lt;/code&gt; &lt;code&gt;version&lt;/code&gt; 拼接而成）：&lt;/p&gt;
&lt;figure class=&quot;highlight groovy&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;project.repositories.mavenLocal().url.toString() - &lt;span class=&quot;string&quot;&gt;&#39;file:&#39;&lt;/span&gt; + group.replace(&lt;span class=&quot;string&quot;&gt;&#39;.&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;/&#39;&lt;/span&gt;) + &lt;span class=&quot;string&quot;&gt;&#39;/&#39;&lt;/span&gt; + name.replace(&lt;span class=&quot;string&quot;&gt;&#39;.&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;/&#39;&lt;/span&gt;) + &lt;span class=&quot;string&quot;&gt;&#39;/&#39;&lt;/span&gt; + version &lt;span class=&quot;comment&quot;&gt;// name  对应的就是依赖的 artifactId&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;同理，&lt;code&gt;gradle.user.home&lt;/code&gt; 下的依赖父目录路径大致是这样：&lt;code&gt;~/.gradle/caches/modules-2/files-2.1/com.google.gson/gson/2.6.2/&lt;/code&gt;，这里要注意，gradle 缓存的 &lt;code&gt;jar&lt;/code&gt; &lt;code&gt;aar&lt;/code&gt; 和 &lt;code&gt;pom&lt;/code&gt; 文件不是在同一个目录的，目录树结构如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7x2wvb.com1.z0.glb.clouddn.com/20171112-111644@2x.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;获取 Gradle Cache 路径的代码如下：&lt;/p&gt;
&lt;figure class=&quot;highlight groovy&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; String getGradleCachePath() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; defaultGradleUserHome = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; File(&lt;span class=&quot;string&quot;&gt;&quot;$&amp;#123;SystemProperties.instance.userHome&amp;#125;/.gradle&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; gradleUserHome = System.getProperty(&lt;span class=&quot;string&quot;&gt;&#39;gradle.user.home&#39;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (gradleUserHome == &lt;span class=&quot;literal&quot;&gt;null&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        gradleUserHome = System.getenv(&lt;span class=&quot;string&quot;&gt;&quot;GRADLE_USER_HOME&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (gradleUserHome == &lt;span class=&quot;literal&quot;&gt;null&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            gradleUserHome = defaultGradleUserHome.absolutePath&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;string&quot;&gt;&quot;$&amp;#123;gradleUserHome&amp;#125;/caches/modules-2/files-2.1/&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;然后再加上依赖的 &lt;code&gt;groupId&lt;/code&gt; &lt;code&gt;artifactId&lt;/code&gt; &lt;code&gt;version&lt;/code&gt; 就可以确定此依赖的父目录路径，跟 &lt;code&gt;mavenLocal&lt;/code&gt; 不同的是，它的的 &lt;code&gt;groupId&lt;/code&gt; 本身就是个目录，而无需使用 “/“ 替换 “.”：&lt;/p&gt;
&lt;figure class=&quot;highlight groovy&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;getGradleCachePath() + group + &lt;span class=&quot;string&quot;&gt;&#39;/&#39;&lt;/span&gt; + name.replace(&lt;span class=&quot;string&quot;&gt;&#39;.&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;/&#39;&lt;/span&gt;) + &lt;span class=&quot;string&quot;&gt;&#39;/&#39;&lt;/span&gt; + version &lt;span class=&quot;comment&quot;&gt;// name  对应的就是依赖的 artifactId&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;不过实际上不管是哪种缓存，我们只要拿到它的父目录，就可以遍历父目录，然后拿到这个具体的依赖，然后加载这个依赖缓存。&lt;/p&gt;
&lt;figure class=&quot;highlight groovy&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; File getAar(String aarParentPath) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; aar = &lt;span class=&quot;literal&quot;&gt;null&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; file = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; File(aarParentPath)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (!file.exists()) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; aar&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    file.eachFileRecurse &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (it.isFile() &amp;amp;&amp;amp; it.absolutePath.endsWith(&lt;span class=&quot;string&quot;&gt;&#39;.aar&#39;&lt;/span&gt;)) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            aar = it&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; aar&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;下载依赖&quot;&gt;&lt;a href=&quot;#下载依赖&quot; class=&quot;headerlink&quot; title=&quot;下载依赖&quot;&gt;&lt;/a&gt;下载依赖&lt;/h3&gt;&lt;p&gt;在 Gradle 里下载依赖有多种方式，而且代码实现都极其简单：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;直接获取要下载的依赖的 url，然后下载，这样整个逻辑就都要自己处理了；&lt;/p&gt;
&lt;figure class=&quot;highlight groovy&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;40&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;41&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;42&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; repoUrls = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; HashSet()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;repoUrls.add(project.repositories.jcenter().url.toString())&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;repoUrls.add(project.repositories.mavenCentral().url.toString())&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//      repoUrls.add(project.repositories.google().url.toString())  gradle plugin 3.0 版本之后要加此仓库&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;project.repositories.each &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;/**&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     * 不处理 FlatDirectoryArtifactRepository 和 IvyArtifactRepository&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (!(it &lt;span class=&quot;keyword&quot;&gt;instanceof&lt;/span&gt; DefaultMavenLocalArtifactRepository) &amp;amp;&amp;amp; (it &lt;span class=&quot;keyword&quot;&gt;instanceof&lt;/span&gt; MavenArtifactRepository)) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        repoUrls.add(it.url)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; String getDependencyByDownload(Project project, String dependency, HashSet&amp;lt;String&amp;gt; repoUrls, String mavenLocalDepPath) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; aarPath = &lt;span class=&quot;string&quot;&gt;&#39;&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;try&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; providedAarParent = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; File(mavenLocalDepPath)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (!providedAarParent.exists()) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            providedAarParent.mkdirs()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; split = dependency.split(&lt;span class=&quot;string&quot;&gt;&#39;:&#39;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; depPath = split[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;].replace(&lt;span class=&quot;string&quot;&gt;&#39;.&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;/&#39;&lt;/span&gt;) + &lt;span class=&quot;string&quot;&gt;&#39;/&#39;&lt;/span&gt; + split[&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;].replace(&lt;span class=&quot;string&quot;&gt;&#39;.&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;/&#39;&lt;/span&gt;) + &lt;span class=&quot;string&quot;&gt;&#39;/&#39;&lt;/span&gt; + split[&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; depName = split[&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;] + &lt;span class=&quot;string&quot;&gt;&#39;-&#39;&lt;/span&gt; + split[&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;] + &lt;span class=&quot;string&quot;&gt;&#39;.aar&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; depFile = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; File(providedAarParent, depName)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (depFile.exists()) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; depFile.absolutePath&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (String &lt;span class=&quot;string&quot;&gt;url :&lt;/span&gt; repoUrls) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; repoDepUrl = url.toString() + depPath + &lt;span class=&quot;string&quot;&gt;&#39;/&#39;&lt;/span&gt; + depName&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (!repoDepUrl.startsWith(&lt;span class=&quot;string&quot;&gt;&#39;file:&#39;&lt;/span&gt;)) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                project.logger.info &lt;span class=&quot;string&quot;&gt;&#39;repoDepUrl : &#39;&lt;/span&gt; + repoDepUrl&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                FileUtils.copyURLToFile(&lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; URL(repoDepUrl), depFile)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                aarPath = &lt;span class=&quot;string&quot;&gt;&quot;$&amp;#123;providedAarParent.absolutePath&amp;#125;/$&amp;#123;depName&amp;#125;&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;break&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125; &lt;span class=&quot;keyword&quot;&gt;catch&lt;/span&gt; (Exception e) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        project.logger.error e.toString()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        aarPath = &lt;span class=&quot;literal&quot;&gt;null&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; aarPath&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;使用 &lt;code&gt;detachedConfiguration&lt;/code&gt; ，这可能是最常用最正规的方式了（atlas 里是这么做的）；&lt;/p&gt;
&lt;figure class=&quot;highlight groovy&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; String getDependencyByDownload(Project project, String dependency) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; configuration = project.configurations.detachedConfiguration(project.dependencies.create(dependency))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    configuration.setTransitive(&lt;span class=&quot;literal&quot;&gt;false&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    configuration.singleFile.absolutePath&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;自定义 &lt;code&gt;Dependency Scope&lt;/code&gt;，使其继承（&lt;code&gt;extendsFrom&lt;/code&gt;） &lt;code&gt;Gradle&lt;/code&gt; 提供的已有的 &lt;code&gt;Dependency Scope&lt;/code&gt;，这是最投机取巧也最省时省力的方式（apt 就是这么做的）；&lt;/p&gt;
&lt;figure class=&quot;highlight groovy&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;project.configurations.create(&lt;span class=&quot;string&quot;&gt;&#39;providedAar&#39;&lt;/span&gt;).extendsFrom(project.configurations.getByName(&lt;span class=&quot;string&quot;&gt;&#39;provided&#39;&lt;/span&gt;))&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;那么，我们这里下载依赖应该选取哪种方式呢？答案是只能是&lt;strong&gt;第一种&lt;/strong&gt;方式。那么问题来了，这是为什么呢？这个问题的答案也是下面一节要讲述的的内容。&lt;/p&gt;
&lt;h3 id=&quot;生命周期之解决依赖关系&quot;&gt;&lt;a href=&quot;#生命周期之解决依赖关系&quot; class=&quot;headerlink&quot; title=&quot;生命周期之解决依赖关系&quot;&gt;&lt;/a&gt;生命周期之解决依赖关系&lt;/h3&gt;&lt;p&gt;Gradle 整个构建过程，生命周期分为三个阶段：&lt;code&gt;Initiliazatin&lt;/code&gt; &lt;code&gt;Configuration&lt;/code&gt; &lt;code&gt;Execution&lt;/code&gt;，而 &lt;code&gt;resolveDependencies&lt;/code&gt; 之前，调用 &lt;code&gt;detachedConfiguration&lt;/code&gt; 是没有用的，而我们要去 hook 的是&lt;code&gt;resolveDependencies&lt;/code&gt; 这个过程，显然 &lt;code&gt;detachedConfiguration&lt;/code&gt; 这种方式就不合适了。&lt;/p&gt;
&lt;p&gt;而第三种方式，老实讲，我不知道为什么不行，按照我的有限理解，应该是可以的，但是我试了之后，确实不可以，这个问题留待以后再看吧。&lt;/p&gt;
&lt;p&gt;所以我们直接使用第一种方式是不是就可以正常下载了呢？其实也不是。还是考虑到生命周期的问题，我们必须要去 hook &lt;code&gt;resolveDependencies&lt;/code&gt; 这个过程，不是我们经常看到的 &lt;code&gt;afterEvaluate&lt;/code&gt; 或者 &lt;code&gt;beforeEvaluate&lt;/code&gt;，因此，我们只能通过给 gradle 添加监听去实现，而且在 hook 之后，要手动 remove 这个监听。&lt;/p&gt;
&lt;figure class=&quot;highlight groovy&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;project.gradle.addListener(&lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; DependencyResolutionListener() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;annotation&quot;&gt;@Override&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;typename&quot;&gt;void&lt;/span&gt; beforeResolve(ResolvableDependencies dependencies) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        project.configurations.getByName(&lt;span class=&quot;string&quot;&gt;&#39;providedAar&#39;&lt;/span&gt;).dependencies.each &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; group = it.group&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; name = it.name&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; version = it.version&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; dependency = &lt;span class=&quot;string&quot;&gt;&quot;$&amp;#123;it.group&amp;#125;:$&amp;#123;name&amp;#125;:$&amp;#123;version&amp;#125;&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            project.logger.info &lt;span class=&quot;string&quot;&gt;&#39;dependency : &#39;&lt;/span&gt; + dependency&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        project.gradle.removeListener(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;annotation&quot;&gt;@Override&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;typename&quot;&gt;void&lt;/span&gt; afterResolve(ResolvableDependencies dependencies) &amp;#123;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;从-Aar-里获取-Jar&quot;&gt;&lt;a href=&quot;#从-Aar-里获取-Jar&quot; class=&quot;headerlink&quot; title=&quot;从 Aar 里获取 Jar&quot;&gt;&lt;/a&gt;从 Aar 里获取 Jar&lt;/h3&gt;&lt;p&gt;这一步就比较简单了，就是从 zip 包里读取一个 entry，然后输入输出流转成文件存储即可。&lt;/p&gt;
&lt;figure class=&quot;highlight groovy&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;typename&quot;&gt;void&lt;/span&gt; getJarFromAar(Project project, File aar) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; aarName = aar.name&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; zipFile = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; ZipFile(aar)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;try&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; entries = zipFile.entries()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt; (entries.hasMoreElements()) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; element = entries.nextElement()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            project.logger.info element.name&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (element.name == &lt;span class=&quot;string&quot;&gt;&#39;classes.jar&#39;&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                InputStream inputStream = zipFile.getInputStream(element)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; file = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; File(aar.parent, aarName - &lt;span class=&quot;string&quot;&gt;&#39;.aar&#39;&lt;/span&gt; + &lt;span class=&quot;string&quot;&gt;&#39;.jar&#39;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                project.logger.info file.absolutePath&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                OutputStream outputStream = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; FileOutputStream(file)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                IOUtils.copy(inputStream, outputStream)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                outputStream.close()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                inputStream.close()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125; &lt;span class=&quot;keyword&quot;&gt;catch&lt;/span&gt; (Exception e) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        project.logger.error e.toString()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125; &lt;span class=&quot;keyword&quot;&gt;finally&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        zipFile.close()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;hr&gt;
&lt;p&gt;最后，还有两个我个人的实践经验：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;从 remote repository 里下载 aar 的存放路径，我是存放在了 &lt;code&gt;mavenLocal()&lt;/code&gt; 里，这是最简单的方式，因为它的匹配规则最简单；&lt;/li&gt;
&lt;li&gt;我在解出来 jar 之后，直接把 jar 放在了 aar 所在的路径，一是因为这是永久缓存，除非你手动删除它，二同样是因为这样最简单。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这就是整个过程了。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;首先得声明一下，其实 &lt;code&gt;provided aar&lt;/code&gt; 这样的需求场景非常少。在 &lt;code&gt;com.android.library&lt;/code&gt; 里可以直接 &lt;code&gt;provided aar&lt;/code&gt;，因此这样的需求只会在 &lt;code&gt;com.android.application&lt;/code&gt; 里存在。同时还得再声明一下，这里说的 &lt;code&gt;provided&lt;/code&gt; 一个 &lt;code&gt;aar&lt;/code&gt;，是只引用 &lt;code&gt;aar&lt;/code&gt; 里的类，而 &lt;code&gt;aar&lt;/code&gt; 里的资源还是没办法引用的。&lt;/p&gt;
&lt;p&gt;而完成插件化之后的微店，就恰恰对这样的需求非常强烈。一个 &lt;code&gt;application module&lt;/code&gt; 里 &lt;code&gt;compile&lt;/code&gt; 了一个&lt;code&gt;aar&lt;/code&gt;，在其他 &lt;code&gt;application moduel&lt;/code&gt; 里也想用这个 &lt;code&gt;aar&lt;/code&gt; 里的类，而作者在发布 &lt;code&gt;aar&lt;/code&gt; 的时候，并没有发布对应的 &lt;code&gt;jar&lt;/code&gt;，这时候我们的做法往往是手动地解压出来 &lt;code&gt;aar&lt;/code&gt; 里的 &lt;code&gt;classes.jar&lt;/code&gt;，然后再在 &lt;code&gt;dependencies&lt;/code&gt; 里添加这个 &lt;code&gt;classes.jar&lt;/code&gt; 的 &lt;code&gt;provided&lt;/code&gt; 依赖。看上去很简单嘛，可问题是遇到一个就要这样做一次，这就好麻烦了。那么有没有一种纯自动的方式去做这个事情呢？这篇文章讲的就是这个事情。
    
    </summary>
    
      <category term="Android" scheme="http://www.easydone.cn/categories/Android/"/>
    
    
      <category term="Android" scheme="http://www.easydone.cn/tags/Android/"/>
    
      <category term="Gradle" scheme="http://www.easydone.cn/tags/Gradle/"/>
    
      <category term="aar" scheme="http://www.easydone.cn/tags/aar/"/>
    
      <category term="provided" scheme="http://www.easydone.cn/tags/provided/"/>
    
  </entry>
  
  <entry>
    <title>不要盲目拒绝计划之外的代码调试</title>
    <link href="http://www.easydone.cn/2017/11/05/"/>
    <id>http://www.easydone.cn/2017/11/05/</id>
    <published>2017-11-05T07:03:05.000Z</published>
    <updated>2017-11-05T13:43:02.000Z</updated>
    
    <content type="html">&lt;p&gt;不知道从什么时候开始，总能听到这样的声音：“这段代码我好久没改过了，肯定不是我的问题，跟我没关系，你不要找我。”那么问题来了，大家都不是傻子，遇到问题来找你，你跟这个问题一定是有关系的，人家不会无缘无故、闲的蛋疼专门找你事。你撒手不管，当了甩手掌柜，心里很爽。那问题谁来解决？&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;我们来分析一下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;如果团队里有一个人这样，每次遇到问题，都跟自己无关，只写自己认为跟自己相关的代码，其他的在他看来跟他无关的代码都不管，那他就会逐渐地跟整个团队割裂开来，他人的优点自己学不来，他人的缺点自己也没法引以为戒，于己于人于整个团队，都是毒瘤一样的存在；&lt;/li&gt;
&lt;li&gt;如果团队里有多个人都是这样的，都只管自己的一亩三分地，那这就不叫团队了，天天自己跟自己玩儿，不了解别人的代码逻辑，整个项目的代码就完全靠每个人对外提供的接口来维系，一旦有人接口设计能力稍微弱一点，那整个项目的代码最终会极其难以维护；&lt;/li&gt;
&lt;li&gt;遇到这样的问题，自己不管，而对于团队来讲，不可能把问题放在那儿不管，那么把问题留给别人，别人把问题解决了，这种情况越来越多，最终进步的就是别人，即便是你也在进步，一直在逃避问题的你，一定没有一直在解决问题的别人进步快，差距就会越来越大；&lt;/li&gt;
&lt;li&gt;反过来讲，你遇到了问题，是不是一定要第一时间就去找你自认为（实际上还不一定）与这问题有关的人呢？是不是自己真的就已经竭尽全力也解决不了？每次遇到问题，就去麻烦别人，习惯性地逃避问题，以为自己甩了锅，捡了便宜，心里窃喜，可实际上与上面讲的那一类人又有什么区别呢？&lt;/li&gt;
&lt;li&gt;对于有分公司的公司来讲，不同两地的同事进行合作开发，一旦遇到这种问题，一方提供了 SDK，另一方使用过程中遇到了问题，双方离的很远，遇到问题最多也只能通过 IM 或者电话沟通，每个人可能还有别的事情在做，这时候还一直等着别人帮你调试，那问题要拖到什么时候？&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;也许最后问题确实解决了，也很可能是这种情况：一个人想：你自己遇到的问题，凭什么让我帮你调？另一个人又想：你的代码出了问题，不找你找谁？找你是给你脸，你还不要脸了？最终同事之间可能也产生了嫌隙，团队慢慢就会让人丧失信心。&lt;/p&gt;
&lt;p&gt;其实说到底还是责任心不足，我始终觉着不管一个人对这个公司或这个项目有没有感情，你揽下了这个活，处于这个位置，就应该尽自己应尽的责任，努力把这个活干好。所谓在其位，谋其政，就是如此。如果整天划水，得过且过，当一天和尚撞一天钟，那不如早撤，以免惹人讨厌。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;不知道从什么时候开始，总能听到这样的声音：“这段代码我好久没改过了，肯定不是我的问题，跟我没关系，你不要找我。”那么问题来了，大家都不是傻子，遇到问题来找你，你跟这个问题一定是有关系的，人家不会无缘无故、闲的蛋疼专门找你事。你撒手不管，当了甩手掌柜，心里很爽。那问题谁来解决？
    
    </summary>
    
      <category term="Tech" scheme="http://www.easydone.cn/categories/Tech/"/>
    
    
      <category term="debug" scheme="http://www.easydone.cn/tags/debug/"/>
    
  </entry>
  
  <entry>
    <title>一个关于Gradle构建缓存的问题</title>
    <link href="http://www.easydone.cn/2017/08/15/"/>
    <id>http://www.easydone.cn/2017/08/15/</id>
    <published>2017-08-15T13:16:50.000Z</published>
    <updated>2017-08-15T14:25:12.000Z</updated>
    
    <content type="html">&lt;h2 id=&quot;问题&quot;&gt;&lt;a href=&quot;#问题&quot; class=&quot;headerlink&quot; title=&quot;问题&quot;&gt;&lt;/a&gt;问题&lt;/h2&gt;&lt;p&gt;我们的项目构建中，有这样一个需求，在编译过程中，将最重要打到 APK 包里的 jar 库全都合并到一个 jar 里。于是，我新建了一个合并 jar 包的任务，插入到了 Gradle Tasks 的&lt;strong&gt;有向非循环图&lt;/strong&gt;里，但是这个过程中遇到这样一个问题：在 Gradle 构建脚本里，调用 &lt;code&gt;ApplicationVariant#apkLibraries&lt;/code&gt; 方法，我发现输出结果时而正确，时而不正确。&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;这段代码我是这样写的：&lt;/p&gt;
&lt;figure class=&quot;highlight groovy&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;afterEvaluate &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    android.applicationVariants.all &amp;#123; ApkVariant variant -&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; buildTypeName = variant.buildType.name&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; task = project.tasks.create &lt;span class=&quot;string&quot;&gt;&quot;jar$&amp;#123;buildTypeName.capitalize()&amp;#125;&quot;&lt;/span&gt;, Jar&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; packageTask = project.tasks.findByName(&lt;span class=&quot;string&quot;&gt;&quot;package$&amp;#123;buildTypeName.capitalize()&amp;#125;&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        task.archiveName = &lt;span class=&quot;string&quot;&gt;&#39;base.jar&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        task.dependsOn packageTask&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        packageTask.finalizedBy task&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        task.outputs.upToDateWhen &amp;#123; &lt;span class=&quot;literal&quot;&gt;false&lt;/span&gt; &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        variant.apkLibraries.each &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            logger.info(&lt;span class=&quot;string&quot;&gt;&#39;apkLibraries ===&amp;gt; &#39;&lt;/span&gt; + it.absolutePath)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            task.from zipTree(it)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        task.destinationDir = file(project.buildDir.absolutePath + &lt;span class=&quot;string&quot;&gt;&quot;/outputs/jar&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        artifacts.add(&lt;span class=&quot;string&quot;&gt;&#39;archives&#39;&lt;/span&gt;, task)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;其实这个问题困扰我好久了，一直悬而未决，不过好在这一切都发生在编译期，如果结果不正确的话，一切错误都可以在编译期暴露出来，而不会影响发版。因此，在解决方案一直苦求而不得的情况下，我并没有把这个问题的优先级列的很高。直到前些天，我实在受不了了（此处省略了 N 多无奈纠结），只好硬着头皮硬上了。结果就有了这篇文章。&lt;/p&gt;
&lt;h2 id=&quot;一些准备工作&quot;&gt;&lt;a href=&quot;#一些准备工作&quot; class=&quot;headerlink&quot; title=&quot;一些准备工作&quot;&gt;&lt;/a&gt;一些准备工作&lt;/h2&gt;&lt;p&gt;首先，我解释一下这段代码的作用，其实 Gradle 对于没接触过的人和习惯于 Java 的人之所以难懂，是因为大量的语法糖省略了许多代码，而 IDE 本身对于智能不全的支持又相当的鸡肋，不管是读还是写，都特别费劲，我们把这段代码补全之后就容易理解多了。&lt;/p&gt;
&lt;figure class=&quot;highlight groovy&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;project.afterEvaluate(&lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Action&amp;lt;Project&amp;gt;() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;annotation&quot;&gt;@Override&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;typename&quot;&gt;void&lt;/span&gt; execute(Project project) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        com.android.build.gradle.AppExtension android = project.findProperty(&lt;span class=&quot;string&quot;&gt;&#39;android&#39;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        android.getApplicationVariants().all(&lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Action&amp;lt;com.android.build.gradle.api.ApplicationVariant&amp;gt;() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;annotation&quot;&gt;@Override&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;typename&quot;&gt;void&lt;/span&gt; execute(com.android.build.gradle.api.ApplicationVariant applicationVariant) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                String buildTypeName = applicationVariant.buildType.name&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                Task task = project.tasks.create(&lt;span class=&quot;string&quot;&gt;&quot;jar$&amp;#123;buildTypeName.capitalize()&amp;#125;&quot;&lt;/span&gt;, Jar)&lt;span class=&quot;comment&quot;&gt;//创建任务&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                Task packageTask = project.tasks.findByName(&lt;span class=&quot;string&quot;&gt;&quot;package$&amp;#123;buildTypeName.capitalize()&amp;#125;&quot;&lt;/span&gt;)&lt;span class=&quot;comment&quot;&gt;//确定需要依赖的任务&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                task.archiveName = &lt;span class=&quot;string&quot;&gt;&#39;base.jar&#39;&lt;/span&gt;&lt;span class=&quot;comment&quot;&gt;//输出文件名&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                task.dependsOn(packageTask)&lt;span class=&quot;comment&quot;&gt;//设置任务依赖的现有构建任务&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                packageTask.finalizedBy(task)&lt;span class=&quot;comment&quot;&gt;//设置任务在构建中的执行时机&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                task.outputs.upToDateWhen &amp;#123; &lt;span class=&quot;literal&quot;&gt;false&lt;/span&gt; &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                Collection&amp;lt;File&amp;gt; apkLibraries = applicationVariant.getApkLibraries()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (File &lt;span class=&quot;string&quot;&gt;file :&lt;/span&gt; apkLibraries) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    project.getLogger().lifecycle(&lt;span class=&quot;string&quot;&gt;&#39;apkLibraries ===&amp;gt; &#39;&lt;/span&gt; + file.getAbsolutePath())&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    task.from zipTree(file)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                task.destinationDir = file(project.buildDir.absolutePath + &lt;span class=&quot;string&quot;&gt;&quot;/outputs/jar&quot;&lt;/span&gt;)&lt;span class=&quot;comment&quot;&gt;//输出目录&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                artifacts.add(&lt;span class=&quot;string&quot;&gt;&#39;archives&#39;&lt;/span&gt;, task)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这样再看，是不是就容易理解多了？其中 &lt;code&gt;afterEvaluate&lt;/code&gt; 和 &lt;code&gt;logger&lt;/code&gt; 都是 &lt;code&gt;project&lt;/code&gt; 的方法，在每个 Gradle 工程里都有一个 &lt;code&gt;project&lt;/code&gt; 对象，在所有的 &lt;code&gt;build.gradle&lt;/code&gt; 文件里都可以直接调用 &lt;code&gt;project&lt;/code&gt; 的所有共有方法和变量（所以说，所谓闭包、lambda 绝对不是学会 Gradle 的关键）。这段代码的目的就是为了输出所有最终打进 APK 包里的依赖，也就是在 &lt;code&gt;build.gradle&lt;/code&gt; 的 &lt;code&gt;dependencies&lt;/code&gt; 结点下面 &lt;code&gt;compile&lt;/code&gt; （未来的 Gradle Plugin 版本可能会变）的所有依赖；顺便说一句，如果要获取 &lt;code&gt;dependencies&lt;/code&gt; 结点下面所有的依赖，将 &lt;code&gt;apkLibraries&lt;/code&gt; 换成 &lt;code&gt;compileLibraries&lt;/code&gt; 即可。这两个 API 在 &lt;code&gt;com.android.build.gradle.api.ApkVariant&lt;/code&gt; 里，而 &lt;code&gt;ApplicationVariant&lt;/code&gt; 继承自 &lt;code&gt;ApkVariant&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7x2wvb.com1.z0.glb.clouddn.com/20170807-185058.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;现象描述&quot;&gt;&lt;a href=&quot;#现象描述&quot; class=&quot;headerlink&quot; title=&quot;现象描述&quot;&gt;&lt;/a&gt;现象描述&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;先从日志输出入手，将正确的结果和不正确的结果放在一起对比后发现，正确的结果里包含两种类型的文件路径，一种是工程 &lt;code&gt;build/intermediates/exploded-aar&lt;/code&gt; 目录下的&lt;strong&gt;临时缓存&lt;/strong&gt;，另一种是 &lt;code&gt;.gradle&lt;/code&gt;、&lt;code&gt;.m2&lt;/code&gt; 和 &lt;code&gt;SDK&lt;/code&gt; 目录下的&lt;strong&gt;永久缓存&lt;/strong&gt;（除非手动删除）；它们还有另外一个特点，前者全都是 aar，后者都是 jar：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7x2wvb.com1.z0.glb.clouddn.com/20170808-085843.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;我们再看一下不正确的结果，很容易发现，这结果里只剩下了 &lt;code&gt;.gradle&lt;/code&gt;、&lt;code&gt;.m2&lt;/code&gt; 和 &lt;code&gt;SDK&lt;/code&gt; 目录下的缓存：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7x2wvb.com1.z0.glb.clouddn.com/20170808-091455.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;也就是说，工程 &lt;code&gt;build&lt;/code&gt; 目录下的临时缓存丢掉了，然后我先执行以下 &lt;code&gt;gradle clean&lt;/code&gt;，将 &lt;code&gt;build&lt;/code&gt; 目录删掉，再重新编译，结果复现了！到了这里，我们可以确认这是个必现的 bug，而不是一开始想的时而正确，时而不正确。&lt;/p&gt;
&lt;p&gt;但是我的打包命令里明明包含了 &lt;code&gt;clean&lt;/code&gt; 任务，为什么在 1 里的结果还是正确的呢？其实这时候，如果对 Gradle 的生命周期有了解的话，就可以猜得到结果了，这说明这段日志打印一定是在 Gradle 生命周期的 &lt;strong&gt;&lt;code&gt;Configuration&lt;/code&gt;&lt;/strong&gt; 阶段输出的，而 &lt;code&gt;clean&lt;/code&gt; 任务的执行必然是在 &lt;strong&gt;&lt;code&gt;Configuration&lt;/code&gt;&lt;/strong&gt; 之后的，这也就解释了为什么单独执行 &lt;code&gt;clean&lt;/code&gt; 任务，再执行 &lt;code&gt;assembleDebug&lt;/code&gt; 任务，得到的结果是错误的，而把 &lt;code&gt;clean&lt;/code&gt; 和 &lt;code&gt;assembleDebug&lt;/code&gt; 放在一起执行得到的结果是正确的。我们将打包命令后面加上 &lt;code&gt;—info&lt;/code&gt; 参数，就可以发现确实是在 &lt;strong&gt;&lt;code&gt;Configuration&lt;/code&gt;&lt;/strong&gt; 过程中打印的日志输出。下图是 Gradle 生命周期的图示。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&quot;http://7x2wvb.com1.z0.glb.clouddn.com/Gradle_LifeCycle.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;再接下来，我新建了个 demo，然后继续之前的操作，一个完全干净的工程，没有 &lt;code&gt;buildDir&lt;/code&gt;，结果出现了下面的结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7x2wvb.com1.z0.glb.clouddn.com/20170808-102417.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;看到这样的结果，我直接就懵逼了… &lt;code&gt;build/intermediates/exploded-aar&lt;/code&gt; 居然消失了！！！跟上面的截图对比之后，发现取而代之的是 &lt;code&gt;$HOME/.android/build-cache&lt;/code&gt; 目录，而且即便没有 &lt;code&gt;build&lt;/code&gt; 临时缓存目录，得到的结果也是正确的。新建的 demo 构建环境跟我们的业务工程唯一的区别就是 Gradle 版本了，我把 demo 的 Gradle 版本降级到跟业务工程一样，结果完全一样了。看来，Google 也意识到了这个 bug，其实也好理解，工程 &lt;code&gt;buildDir&lt;/code&gt; 本就是临时目录，每次 &lt;code&gt;clean&lt;/code&gt; 之后都会删除，而如果使用系统级的缓存目录，执行 &lt;code&gt;clean&lt;/code&gt; 任务就不影响了。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;追本溯源&quot;&gt;&lt;a href=&quot;#追本溯源&quot; class=&quot;headerlink&quot; title=&quot;追本溯源&quot;&gt;&lt;/a&gt;追本溯源&lt;/h2&gt;&lt;p&gt; 接下来我们来看看最新版本的 Android Gradle Plugin 源码里是怎么处理的吧。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;我们在上面的截图里可以看到，调用 &lt;code&gt;androidBuilder.getAllPackagedJars&lt;/code&gt; 方法即可得到 &lt;code&gt;apkLibraries&lt;/code&gt;， &lt;code&gt;AndroidBuild&lt;/code&gt; 里的 &lt;code&gt;getAllPackagedJars&lt;/code&gt; 方法如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7x2wvb.com1.z0.glb.clouddn.com/20170807-190719.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;然后是 &lt;code&gt;VariantConfiguration&lt;/code&gt; 里的 &lt;code&gt;getAllPackagedJars&lt;/code&gt; 方法：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7x2wvb.com1.z0.glb.clouddn.com/20170807-190914.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;接着调到了 &lt;code&gt;Dependency&lt;/code&gt; 类里的 &lt;code&gt;getClasspathFile&lt;/code&gt; 和 &lt;code&gt;getAdditionalClasspath&lt;/code&gt; 方法，而 &lt;code&gt;Dependency&lt;/code&gt; 是一个接口，我们看它的其中一个实现类（其他的也类似）&lt;code&gt;AndroidDependency&lt;/code&gt;，&lt;code&gt;AndroidDependency&lt;/code&gt; 的构造方法是私有的，同时它提供了静态的共有 create 方法，因此创建 &lt;code&gt;AndroidDependency&lt;/code&gt; 都只能调用这些 create 方法，我们只要找到这些 create 方法调用的地方就可以了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7x2wvb.com1.z0.glb.clouddn.com/20170808-113615.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;然后我们可以发现在 &lt;code&gt;DependencyManager&lt;/code&gt; 里调用了 create 初始化 &lt;code&gt;Dependency&lt;/code&gt; 的方法：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7x2wvb.com1.z0.glb.clouddn.com/20170807-191141.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;到这里，就很明朗了。Gradle 构建过去缓存目录有两种方式，用哪种方式，取决于 &lt;code&gt;PrepareLibraryTask.shouldUseBuildCache(buildCache.isPresent(), mavenCoordinates)&lt;/code&gt; 的值，也就是说 &lt;code&gt;buildCache.isPresent()&lt;/code&gt; 为 true，同时依赖版本号里含有 &lt;code&gt;-SNAPSHOT&lt;/code&gt;，而前者需要 &lt;code&gt;buildCache&lt;/code&gt; 不为空：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7x2wvb.com1.z0.glb.clouddn.com/20170808-114331.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;接下来我们可以看 &lt;code&gt;com.android.build.gradle.AndroidGradleOptions&lt;/code&gt; 这个类，这里我们可以看到只要 &lt;code&gt;isBuildCacheEnabled&lt;/code&gt; 这个方法返回 true，上一步里的 &lt;code&gt;buildCache&lt;/code&gt; 就不为空，而 &lt;code&gt;DEFAULT_ENABLE_BUILD_CACHE&lt;/code&gt; 这个默认值恰恰就是 true，而且我们也可以看到在 &lt;code&gt;getBuildCacheDir&lt;/code&gt;  方法里，拼接的 dir 里刚好就有我们上面截图里的 &lt;code&gt;build-cache&lt;/code&gt;，也就是说在新版本的 Gradle Plugin 里，走了步骤 4 里的 if 逻辑，而之前版本 Gradle Plugin 走的是 else 的逻辑。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7x2wvb.com1.z0.glb.clouddn.com/20170808-115844.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;这时候我们再看步骤 4 里的 else 逻辑，里面其实就是一个给 &lt;code&gt;explodedDir&lt;/code&gt; 的赋值操作，有两个常量字符串，他们的值如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7x2wvb.com1.z0.glb.clouddn.com/20170808-120430.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7x2wvb.com1.z0.glb.clouddn.com/20170808-120450.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;拼在一起，刚好就是 &lt;code&gt;build/intermediates/exploded-aar&lt;/code&gt;，这也就是为什么在新版本的 Gradle Plugin 里这个目录消失了的原因。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;然而，难道说要解决这问题，只能升级 Gradle 版本？当然不是，而且我们还可以发现，这样的输出结果并不完全正确，我们想要的是某一个变种（variant）的输出，不同的变种，文件目录是不一样的，而这结果是无论我们是哪一个变种，结果都是所有的变种输出。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;解决方案&quot;&gt;&lt;a href=&quot;#解决方案&quot; class=&quot;headerlink&quot; title=&quot;解决方案&quot;&gt;&lt;/a&gt;解决方案&lt;/h2&gt;&lt;p&gt;我们有必要再重新审阅一下我们的需求，『在编译过程中，将最重要打到 APK 包里的 jar 库全都合并到一个 jar 里』，也就是说这些日志输出应该在 Gradle 生命周期的 &lt;strong&gt;&lt;code&gt;Execution&lt;/code&gt;&lt;/strong&gt; 阶段去打印，而不是 &lt;strong&gt;&lt;code&gt;Configuration&lt;/code&gt;&lt;/strong&gt; 阶段打印。在明确了这一点之后，另外一个更合适的解决方案就呼之欲出了，一点点修改就可以解决。&lt;/p&gt;
&lt;figure class=&quot;highlight groovy&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;afterEvaluate &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    android.applicationVariants.all &amp;#123; ApkVariant variant -&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; buildTypeName = variant.buildType.name&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; task = project.tasks.create &lt;span class=&quot;string&quot;&gt;&quot;jar$&amp;#123;buildTypeName.capitalize()&amp;#125;&quot;&lt;/span&gt;, Jar&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; packageTask = project.tasks.findByName(&lt;span class=&quot;string&quot;&gt;&quot;package$&amp;#123;buildTypeName.capitalize()&amp;#125;&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        task.archiveName = &lt;span class=&quot;string&quot;&gt;&#39;base.jar&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        task.dependsOn packageTask&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        packageTask.finalizedBy task&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        task.outputs.upToDateWhen &amp;#123; &lt;span class=&quot;literal&quot;&gt;false&lt;/span&gt; &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        task.doFirst &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            variant.apkLibraries.each &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                logger.info(&lt;span class=&quot;string&quot;&gt;&#39;apkLibraries ===&amp;gt; &#39;&lt;/span&gt; + it.absolutePath)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                task.from zipTree(it)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        task.destinationDir = file(project.buildDir.absolutePath + &lt;span class=&quot;string&quot;&gt;&quot;/outputs/jar&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        artifacts.add(&lt;span class=&quot;string&quot;&gt;&#39;archives&#39;&lt;/span&gt;, task)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;仅仅是加了个 &lt;code&gt;task.doFirst&lt;/code&gt; 就彻底解决了这个问题，在 task 执行的最开始先去获取需要处理的文件即可。折腾这么久，这样的结果看上去居然与过程几乎没什么关系…不过这过程才是学习最大的意义所在吧。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;问题&quot;&gt;&lt;a href=&quot;#问题&quot; class=&quot;headerlink&quot; title=&quot;问题&quot;&gt;&lt;/a&gt;问题&lt;/h2&gt;&lt;p&gt;我们的项目构建中，有这样一个需求，在编译过程中，将最重要打到 APK 包里的 jar 库全都合并到一个 jar 里。于是，我新建了一个合并 jar 包的任务，插入到了 Gradle Tasks 的&lt;strong&gt;有向非循环图&lt;/strong&gt;里，但是这个过程中遇到这样一个问题：在 Gradle 构建脚本里，调用 &lt;code&gt;ApplicationVariant#apkLibraries&lt;/code&gt; 方法，我发现输出结果时而正确，时而不正确。
    
    </summary>
    
      <category term="Android" scheme="http://www.easydone.cn/categories/Android/"/>
    
    
      <category term="Android" scheme="http://www.easydone.cn/tags/Android/"/>
    
      <category term="Gradle" scheme="http://www.easydone.cn/tags/Gradle/"/>
    
  </entry>
  
  <entry>
    <title>Repo VS Submodule</title>
    <link href="http://www.easydone.cn/2017/04/24/"/>
    <id>http://www.easydone.cn/2017/04/24/</id>
    <published>2017-04-24T15:16:50.000Z</published>
    <updated>2017-04-24T15:24:02.000Z</updated>
    
    <content type="html">&lt;h2 id=&quot;微店工程结构改造历程&quot;&gt;&lt;a href=&quot;#微店工程结构改造历程&quot; class=&quot;headerlink&quot; title=&quot;微店工程结构改造历程&quot;&gt;&lt;/a&gt;微店工程结构改造历程&lt;/h2&gt;&lt;p&gt;虽然工程结构、版本控制只是日常开发非常小的一块内容，但是在一个现代的大型项目里，如果构建一个更高效地组织形式，是每一个团队都必须正视和解决的问题。&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;从 16 年的四月份微店 Android 开始了平台化改造，为了配合平台化开发，微店的工程结构经历了多次大的调整。调整之后，稳定使用较长的有两个节点，第一次是全部模块插件化之后，工程结构由一个大的 Git 库改造成了 &lt;code&gt;submodule&lt;/code&gt; 的形式；第二次是在使用了较长时间 &lt;code&gt;submodule&lt;/code&gt; 之后，遇到了不少问题，经过权衡，改为了 &lt;code&gt;repo&lt;/code&gt; 的形式，一直用到现在，目前业务开发反馈良好。&lt;/p&gt;
&lt;h2 id=&quot;微店工程结构的特点&quot;&gt;&lt;a href=&quot;#微店工程结构的特点&quot; class=&quot;headerlink&quot; title=&quot;微店工程结构的特点&quot;&gt;&lt;/a&gt;微店工程结构的特点&lt;/h2&gt;&lt;p&gt;微店工程插件化之后，工程结构呈现这样的形式：一个宿主 module，若干个子 module，最终打包的时候，需要先将子 module 打成一个二进制的文件，然后使用宿主 module 包裹子 module，将宿主 module 打成一个 APK，在运行的时候，动态地去读取二进制的子 module 文件。&lt;/p&gt;
&lt;h2 id=&quot;submodule—踩坑之旅&quot;&gt;&lt;a href=&quot;#submodule—踩坑之旅&quot; class=&quot;headerlink&quot; title=&quot;submodule—踩坑之旅&quot;&gt;&lt;/a&gt;submodule—踩坑之旅&lt;/h2&gt;&lt;p&gt;通过对微店工程结构的描述，我们很容易想到使用 submodule 去管理微店工程。在 submodule 里，每个 module 都是一个 Git 库，各个 module 提交代码相互不干扰，同时一个主 module 管理若干个子 module，这样在同一个工程里，不同的 module 既是相互独立的，所有的 module 代码又可以存在同一个工程里。相互独立就意味着我们各个业务并行开发不受干扰，代码共存又让我们在调试的时候可以引用到其他 module 的代码。仿佛 submodule 就是为了并行开发量身定做的，于是我们花了很大力气将工程切到了 submodule 上，然而理想很美好，现实却是残酷的…&lt;/p&gt;
&lt;p&gt;在 submodule 的主工程里，每个 module 在 Git 库里的表现形式是这个 module 的 name 加上一串数字和字母，这串数字和字母代表的是 Git 提交记录，我们知道每次 Git 提交都会有一个 &lt;strong&gt;sha&lt;/strong&gt; 记录值，这个 &lt;strong&gt;sha&lt;/strong&gt; 值记录了我们每一次的 Git 提交记录，通过它，我们可以进行克隆、回滚等操作。&lt;/p&gt;
&lt;p&gt;举个例子，小王和小刘同时开发 message 这个模块，当前在主 module 里记录的 message 模块的 &lt;strong&gt;sha&lt;/strong&gt; 值是 &lt;code&gt;fc0282f7&lt;/code&gt;，也就是 &lt;code&gt;message@fc0282f7&lt;/code&gt; ，然后小王提交了代码，假设这次提交记录的 &lt;strong&gt;sha&lt;/strong&gt; 是 &lt;code&gt;ab8762f0&lt;/code&gt;，这时候小王主 module 管理的 message 版本就是 &lt;code&gt;ab8762f0&lt;/code&gt;，但是主 module 的 remote 库里管理的 message 版本还是 &lt;code&gt;fc0282f7&lt;/code&gt;，因此为了保持同步，我们在提交了 message 模块的更新之后，必须要把自己主 module 里的这个更新的 &lt;code&gt;sha&lt;/code&gt; 值也提交上去。如果小王忘了提交自己主 module 里的 &lt;code&gt;sha&lt;/code&gt; 值，这时候小刘也提交了 message 模块的代码，这时候主 module 的 &lt;code&gt;sha&lt;/code&gt; 值就会落后两个版本，这样问题就产生了，如果这时候再更新主 module 代码，这个主 module 的 &lt;code&gt;sha&lt;/code&gt; 值就会产生冲突，无法更新、无法回滚、无法合并（Android 组同事印象应该会很深刻）。&lt;/p&gt;
&lt;p&gt;由此，可以看到，这些问题是由我们一些根深蒂固的使用习惯造成的，尤其是在多人开发的时候，很难要求每个人都对一个新的技能点能够完全掌握。而且，按照我们的初衷，业务开发只需要负责自己模块的代码就可以了，而 submodule 需要把所有模块的代码都下载到自己本地，并且显式地导入 IDE，这样 &lt;strong&gt;Gradle 的配置检查、同步就会很耗时&lt;/strong&gt;。在使用了近半年之后，这种状况依然没有任何好转，我们只好寻求更好的解决方案。&lt;/p&gt;
&lt;p&gt;当然，对于 submodule 的使用，如果能注意以下几点，也能用的很顺畅：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;最最重要的一个原则，也是使用 Git 最基本的一个原则：&lt;strong&gt;先更新再提交&lt;/strong&gt;，先更新再提交，先更新再提交；&lt;/li&gt;
&lt;li&gt;尽量使用&lt;strong&gt;命令行终端&lt;/strong&gt;，至少要学会基本的 Git 命令，不要太依赖 GUI 工具；&lt;/li&gt;
&lt;li&gt;在子 module 里 push 了代码之后，一定要提交主 module 里对应的 &lt;code&gt;sha&lt;/code&gt; 值；&lt;/li&gt;
&lt;li&gt;在主 module 里 &lt;code&gt;git pull&lt;/code&gt; 之后，一定要执行 &lt;code&gt;git status&lt;/code&gt;，要确认 submodule 是否有修改，如有修改，需执行 &lt;code&gt;git submodule update&lt;/code&gt;；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;git submodule update&lt;/code&gt; 并不会将子 module 切到任何一个分支，而是一个游离状态的 HEAD state（这一点跟 repo 类似，后面也会讲到），因此在做任何子 module 的操作之前，一定要确认子 module 已经在需要操作的分支上；&lt;/li&gt;
&lt;li&gt;假如说在游离的 HEAD state 下进行了代码修改，然后又提交了，这时候可以先切到需要提交的分支，然后再用 &lt;code&gt;git cherry-pick xxx&lt;/code&gt;，再 push 即可；&lt;/li&gt;
&lt;li&gt;请尽量使用 &lt;code&gt;git submodule foreach &amp;#39;pwd &amp;amp;&amp;amp; git pull&amp;#39;&lt;/code&gt;，这样的组合命令，单引号里的 &lt;code&gt;git pull&lt;/code&gt; 可以换成其他的终端命令，而不仅仅是 git 命令（这也和 repo 里的类似）。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;repo—重新上路&quot;&gt;&lt;a href=&quot;#repo—重新上路&quot; class=&quot;headerlink&quot; title=&quot;repo—重新上路&quot;&gt;&lt;/a&gt;repo—重新上路&lt;/h2&gt;&lt;p&gt;针对我们使用 submodule 过程中遇到的问题，我们希望能找到一种既能满足像 submodule 那样，各模块相互独立以便于开发，各模块的组织结构形式能方便调试，又能避免像 submodule 那样，模块提交代码对其他模块造成影响。于是我们又重新上路了。经过长时间的考察，我们发现 repo 正是这样一种方案。&lt;/p&gt;
&lt;p&gt;repo 引入了一个新角色，这个新角色来管理所有的 module，而不是像 submodule 那样，建立一种主从关系，用主 module 管理子 module。在 repo 里，所有 module 都是平级关系，每个 module 的版本管理完全独立于任何其他 module，不会像 submodule 那样，提交了子 module 代码，也会对主 module 造成影响。&lt;/p&gt;
&lt;p&gt;实际上，我们在使用过程中，还发现了另外一些好处：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;剥离了主 module 和子 module 的关系，检出、同步、提交等操作都比 sumodule 要快了好多倍；&lt;/li&gt;
&lt;li&gt;只需要检出需要开发的模块的代码，代码量减少了很多，正常情况下，本来要检出 30 多个模块代码，现在只需要一个模块代码，考虑到 Gradle 构建生命周期，整个构建时间在我们插件化改造之后又一次大大降低了；&lt;/li&gt;
&lt;li&gt;模块管理配置由一个陌生的 .gitmodules 变成了所有人都更熟悉的 xml 文件，便于配置管理。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在 repo 真正的工程代码同一级，多出了一个 .repo 目录，默认情况下是隐藏目录，这里面存储了整个 repo 工程的信息。针对 repo，也有一些使用建议：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;最好新建一个空目录，在这个新建的空目录里检出整个 repo 工程，保证 repo 工程与其他目录隔离开来；&lt;/li&gt;
&lt;li&gt;正常情况下，我们没办法把 repo 的工程配置文件 default.xml 和软链接 manifest.xml 导入到 IDE 里，同步不同模块的代码就不太方便，可以新建一个 default.xml 的软链接放在代码工程里，这样就可以在 IDE 操作；&lt;/li&gt;
&lt;li&gt;默认情况下只保留必备的几个 git 库，开发需要哪个模块，就将哪个模块 git 库解开注释；&lt;/li&gt;
&lt;li&gt;请尽量使用 &lt;code&gt;repo forall -c &amp;#39;pwd &amp;amp;&amp;amp; git pull&amp;#39;&lt;/code&gt; 这样的组合命令执行代码同步，这一点跟 submodule 类似；&lt;/li&gt;
&lt;li&gt;类似 submodule，使用 repo 把代码下载下来之后，每个 module 同样是一个游离的 HEAD state，需要手动切换到 master 分支（或需要操作的分支），执行 &lt;code&gt;repo forall -c git checkout master&lt;/code&gt; 即可，这里有一个坑，可能执行一遍并不能切换到主分支，执行完切换分支任务，需要 &lt;code&gt;repo forall -c &amp;#39;pwd &amp;amp;&amp;amp; git branch&amp;#39;&lt;/code&gt; check 一下。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;以后的工作&quot;&gt;&lt;a href=&quot;#以后的工作&quot; class=&quot;headerlink&quot; title=&quot;以后的工作&quot;&gt;&lt;/a&gt;以后的工作&lt;/h2&gt;&lt;p&gt;在工程模块化的今天，虽然我们已经踩了很多坑，做了很多优化，现在也逐渐适应了 repo 的工作方式，但是还存在如下一些问题：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;一些先进的经验往往伴随着一些新技能的引入，如何让使团队里每个开发人员都尽快接受，这个是重中之重；&lt;/li&gt;
&lt;li&gt;因为权限的问题，我们有非常多的教训，如何对团队里每个人的代码的权限和模块发布权限进行控制，这一点需要不断的完善；&lt;/li&gt;
&lt;li&gt;非自己开发的模块，由源码依赖改为二进制包之后，如何保证调试效率，这是我们至今尚未完美解决的一个难题。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;接下来，我们还会对现有的不断地改进，以期能够达到对日常业务开发更加友好的状态。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;微店工程结构改造历程&quot;&gt;&lt;a href=&quot;#微店工程结构改造历程&quot; class=&quot;headerlink&quot; title=&quot;微店工程结构改造历程&quot;&gt;&lt;/a&gt;微店工程结构改造历程&lt;/h2&gt;&lt;p&gt;虽然工程结构、版本控制只是日常开发非常小的一块内容，但是在一个现代的大型项目里，如果构建一个更高效地组织形式，是每一个团队都必须正视和解决的问题。
    
    </summary>
    
      <category term="Tech" scheme="http://www.easydone.cn/categories/Tech/"/>
    
    
      <category term="repo" scheme="http://www.easydone.cn/tags/repo/"/>
    
      <category term="submodule" scheme="http://www.easydone.cn/tags/submodule/"/>
    
  </entry>
  
  <entry>
    <title>你在感动什么</title>
    <link href="http://www.easydone.cn/2017/02/28/"/>
    <id>http://www.easydone.cn/2017/02/28/</id>
    <published>2017-02-28T15:38:56.000Z</published>
    <updated>2017-02-28T16:05:01.000Z</updated>
    
    <content type="html">&lt;p&gt;花了十三个小时，总算是把『白夜行』看完了。这是一个好故事，东野圭吾对于故事整体架构的把控还是很到位的，前面出现的伏笔，后面都能遥相呼应。&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;虽然作为一个悬疑故事，这一点是必不可少的，但是作者能够将其构造的如此完整，足见其功力。因此，即便我觉着某些情节设定上有 bug，这仍然是一部不错的小说。&lt;/p&gt;
&lt;p&gt;但是，我要说的显然不是这个。事实上，在看这本书之前，微信读书就一直给我的 Timeline 上推这个书的书评，因此某种程度上讲，正是因为看了这些书评，我才打算看这本书。而这些书评都是怎么讲的呢？“男女主身世凄苦，可惜可怜，却又互相依偎，彼此照亮，所以又可敬可佩，感天动地”。呵呵，看完全书之后，我只想问一句：你何来的感动？何来的同情？何来的谅解？这是高中政治课本吗？你要这样表现自己的辩证法学的是多么让老师心花怒放？&lt;/p&gt;
&lt;p&gt;做人做事，是非曲直，善恶黑白，本不是什么难以分辨的事，从来不存在什么换个角度看问题，恶就变得可以理解，变得值得同情，甚至还会让人感动。因为你受了伤害，所以你伤害别人就应该被谅解，应该被人同情。这是什么道理？整本书，越往后面看，我愈发觉着这同情心是多么可怜、可笑、可憎。&lt;/p&gt;
&lt;p&gt;世界上每天都有各种各样的事情在发生，然而它本身却本不复杂，不知道从什么时候开始，这个世界就从每个人都愿意表达自己，变成了轻易就被别人左右思想了。遇事急着看别人的看法，知乎上到处都是『怎样看待 xxx』，仿佛知道了别人怎样看待之后，自己就可以有更正确的三观一样。一直在等别人的看法的人，往往就像墙头草，没有主见，没有独立的思考能力。一篇文章，甚至是一句话，就可以让他的想法发生一百八十度的大转弯。曾经罗玉凤之所以会被洗白，成为励志努力的代言人，也是拜这类人所赐吧，而他们最终又会大义凛然地痛斥剧情反转。&lt;/p&gt;
&lt;p&gt;不论何时，都请有自己独立的思考能力，不要被一段话，一篇文章，一本书左右了自己的人生观，价值观和世界观。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;花了十三个小时，总算是把『白夜行』看完了。这是一个好故事，东野圭吾对于故事整体架构的把控还是很到位的，前面出现的伏笔，后面都能遥相呼应。
    
    </summary>
    
      <category term="随笔" scheme="http://www.easydone.cn/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="独立思考" scheme="http://www.easydone.cn/tags/%E7%8B%AC%E7%AB%8B%E6%80%9D%E8%80%83/"/>
    
      <category term="白夜行" scheme="http://www.easydone.cn/tags/%E7%99%BD%E5%A4%9C%E8%A1%8C/"/>
    
  </entry>
  
  <entry>
    <title>选择</title>
    <link href="http://www.easydone.cn/2017/02/03/"/>
    <id>http://www.easydone.cn/2017/02/03/</id>
    <published>2017-02-03T13:51:04.000Z</published>
    <updated>2017-02-03T15:41:11.000Z</updated>
    
    <content type="html">&lt;p&gt;昨天去看了电影《乘风破浪》，电影一般，算不上佳片，不过也绝对称不上是烂片。由于之前看了一些所谓的职业影评人的评论，抱着将信将疑的态度去看电影，反倒因为低期待值对影片产生了更多的好感。何况，自从韩寒也不再年轻之后，我也成了半个韩粉。&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;吴李冰：1分&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;常用笔名LOOK，影评人，《虹膜》电影杂志编辑总监。&lt;/p&gt;
&lt;p&gt;翻来覆去的低阶笑话勉强忍忍，把我最熟悉的九十年代江南小镇生活拍得如此没有质感也算是意料之中，黑帮桥段形同儿戏也许可以怪怪审查。毕竟韩某人艺术水准摆在那里不能要求太高，最无法忍的是宣扬庸俗不堪腐朽至极的成功学，此类电影在我这里一律差评。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这时候，再看这些所谓的影评人，还是『电影杂志编辑&lt;strong&gt;总监&lt;/strong&gt;』的评论，你会发现要写影评，门槛真的好低。其实也好理解，毕竟在那么『专业』的豆瓣上，一些人即便没看过电影也能随便扯上几句，还能上评论热门。能从电影里提炼出来『成功学』，这水准，还是个『电影杂志编辑&lt;strong&gt;总监&lt;/strong&gt;』。这就好比你去面试，其中一道面试题是反转二叉树，最后面试官对你的评语是：『一切用伪代码表示算法的回答都是垃圾』。我一直以为作为一个影评人，应该把重点放在对电影的评论上的，而不是通过一口一个『x某人』贬低别人的人格来彰显自己作为一个『嘴炮』的优越感。作为一个影评人，你的责任感呢？&lt;/p&gt;
&lt;p&gt;不管从事任何职业，请先学会做人。&lt;/p&gt;
&lt;p&gt;看吧，『选择』无处不在。哪怕是影评人，也可以选择是否要在评论电影的时候夹带私货，顺带恶心一下自己讨厌的人。再看看我，虽然我是半个韩粉，但我依然选择客观地评价『借评价韩寒的电影来评价韩寒的人』。这就是差距。&lt;/p&gt;
&lt;p&gt;前些天还看了《比利·林恩的中场战事》，这是我看的第三部李安的电影，之前是《卧虎藏龙》和《色戒》。年前看了《长城》，李安和张艺谋都是大导演，几十年前，张艺谋的成就甚至要高过李安，而如今，两个人走了完全不一样的道路，你很难说张艺谋的艺术水准真的就不如李安；但是路都是自己走出来的，一个人做出怎样的选择决定了他的成就的上限。以前我也一直以为张艺谋对于中国色彩的执着乃至狂热，并因此走上商业大片之路才是向世界展示中国最好的方式；直到看到了李安，我才发现世界眼里的中国不应该是这么肤浅的。虽然，张艺谋依然是一位非常优秀的导演。&lt;/p&gt;
&lt;p&gt;我不喜欢年少写小说的韩寒，也不喜欢韩寒写的小说，《三重门》《像少年啦飞驰》《长安乱》《一座城池》，我都看过，都不喜欢。自从他的生活里更多地出现了小猫小狗小孩子、生活生色生意人，跟着这个不断在变的世界一起变化之后，我才成了半个韩粉。在我的观念里，&lt;strong&gt;选择了责任才意味着成长&lt;/strong&gt;。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;昨天去看了电影《乘风破浪》，电影一般，算不上佳片，不过也绝对称不上是烂片。由于之前看了一些所谓的职业影评人的评论，抱着将信将疑的态度去看电影，反倒因为低期待值对影片产生了更多的好感。何况，自从韩寒也不再年轻之后，我也成了半个韩粉。
    
    </summary>
    
      <category term="随笔" scheme="http://www.easydone.cn/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="选择，电影" scheme="http://www.easydone.cn/tags/%E9%80%89%E6%8B%A9%EF%BC%8C%E7%94%B5%E5%BD%B1/"/>
    
  </entry>
  
  <entry>
    <title>ProGuard在插件化里的应用</title>
    <link href="http://www.easydone.cn/2017/01/02/"/>
    <id>http://www.easydone.cn/2017/01/02/</id>
    <published>2017-01-02T02:48:03.000Z</published>
    <updated>2017-01-02T06:51:40.000Z</updated>
    
    <content type="html">&lt;p&gt;Android 里比较常见的混淆方案就是 &lt;a href=&quot;https://www.guardsquare.com/en/proguard&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;ProGuard&lt;/a&gt; 和 &lt;a href=&quot;https://www.guardsquare.com/en/dexguard&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;DexGuard&lt;/a&gt;，都是 GuardSquare 的产品，前者免费，后者收费；同时，GuardSquare 还推出了 iOS 的混淆方案 &lt;a href=&quot;https://www.guardsquare.com/en/ixguard&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;iXGuard&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;我们用的方案是 ProGuard，因此这里的讨论只针对 ProGuard，源码见这里 &lt;a href=&quot;https://sourceforge.net/projects/proguard/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://sourceforge.net/projects/proguard/&lt;/a&gt; 。&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;功能&quot;&gt;&lt;a href=&quot;#功能&quot; class=&quot;headerlink&quot; title=&quot;功能&quot;&gt;&lt;/a&gt;功能&lt;/h1&gt;&lt;p&gt;ProGuard 为我们做了这么几项工作：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;shink（压缩）；&lt;/li&gt;
&lt;li&gt;optimize（优化）；&lt;/li&gt;
&lt;li&gt;obfuscate（混淆）；&lt;/li&gt;
&lt;li&gt;preverify（预校验）；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;也就是说我们常说的混淆，并不仅仅指的是混淆，而是 ProGuard，而混淆只是其多个功能里的一个。在 Android 里，现在 ProGuard 的实现方式实际上有两种：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;一种是传统的方式，在 proguard.pro 文件里配置规则，这种方式，更便于集中管理，这里有一点需要注意，proguardFile 是可以配置多个的，我们的插件化里，有一个公共的 proguard-rules-base.pro，是归所有模块共用的，还有一个 proguard-rules.pro，这是每个模块独有的；&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7x2wvb.com1.z0.glb.clouddn.com/proguard/20170102-2@2x.png&quot; alt=&quot;img&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7x2wvb.com1.z0.glb.clouddn.com/proguard/20170102-1@2x.png&quot; alt=&quot;img&quot;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;另一种是引入 support-annotation 包，使用 @keep 注解，这种方式，与日常的开发结合更紧密。&lt;br&gt;&lt;img src=&quot;http://7x2wvb.com1.z0.glb.clouddn.com/proguard/20170102-0@2x.png&quot; alt=&quot;img&quot;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;shink&quot;&gt;&lt;a href=&quot;#shink&quot; class=&quot;headerlink&quot; title=&quot;shink&quot;&gt;&lt;/a&gt;shink&lt;/h2&gt;&lt;p&gt;的目的是为了移除在 App 运行过程中，用不到的类和方法，这样可以缩减方法数，进而缩小  Apk 体积，是避免达到 65535 方法数的一个很好的措施。但是由于我们的插件化方案，对于这一步，我们就要慎之又慎，因为每个模块都是独立的 Apk，虽然不存在了 65535 的问题，但是一些会被其他模块调用但是在自身模块却不会调用的类或方法，经过 ProGuard 之后，就会被 shink 掉，此时就会有 ClassNotFountException 或 NoSuchMethodError，这种一般也比较好解，根据报错，将对应的类或方法 keep 掉即可。详细参数介绍看这里&lt;a href=&quot;https://www.guardsquare.com/en/proguard/manual/usage#shrinkingoptions&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;shrinkingoptions&lt;/a&gt; 。&lt;/p&gt;
&lt;h2 id=&quot;optimize&quot;&gt;&lt;a href=&quot;#optimize&quot; class=&quot;headerlink&quot; title=&quot;optimize&quot;&gt;&lt;/a&gt;optimize&lt;/h2&gt;&lt;p&gt;可以在字节码级别对代码进行优化，默认启用，可以设置不启用。详细参数介绍可以看这里&lt;a href=&quot;https://www.guardsquare.com/en/proguard/manual/usage#optimizationoptions&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;optimizationoptions&lt;/a&gt; 。经过优化，可能会删除一些 log 信息，或者删除被调用没有返回值的方法，或者一些常亮引用直接就使用字符串数字本身了，但是需要注意的是对于 library 里是无效的，同样它可以合并接口，通过减少类来优化。对于我们插件化来说，就也可能出现跟 shink 一样的情况，也需要注意。&lt;/p&gt;
&lt;h2 id=&quot;obfuscate&quot;&gt;&lt;a href=&quot;#obfuscate&quot; class=&quot;headerlink&quot; title=&quot;obfuscate&quot;&gt;&lt;/a&gt;obfuscate&lt;/h2&gt;&lt;p&gt;就很好理解了，也就是我们经常说的混淆，通过设置一些字符，将我们代码里的类名、方法名、变量名替换为这些设置的字符，这些字符组合起来就是一个字典，默认的字典就是我们常常看到的 abcd 之类的，我们可以自己指定一些自定义的字典，增加反编译难度，主要是这样三个参数：&lt;code&gt;-obfuscationdictionary filename&lt;/code&gt; &lt;code&gt;-classobfuscationdictionary filename&lt;/code&gt; &lt;code&gt;-packageobfuscationdictionary filename&lt;/code&gt;，在 proguard.pro 里配置一下就可以了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7x2wvb.com1.z0.glb.clouddn.com/proguard/20170102-9@2x.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;最终的混淆结果就像下面这样：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7x2wvb.com1.z0.glb.clouddn.com/proguard/20170102-10@2x.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;详细参数介绍看这里&lt;a href=&quot;https://www.guardsquare.com/en/proguard/manual/usage#obfuscationoptions&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;obfuscationoptions&lt;/a&gt; 。混淆是保护 App 很好的手段，正常情况下，我们根据编译过程中的 warning 警告就可以确定哪些类不应该被混淆，但是由于我们的插件化方案，造成了编译期的警告全都不可用了，只能通过运行期的报错信息来处理混淆。&lt;/p&gt;
&lt;h2 id=&quot;preverify&quot;&gt;&lt;a href=&quot;#preverify&quot; class=&quot;headerlink&quot; title=&quot;preverify&quot;&gt;&lt;/a&gt;preverify&lt;/h2&gt;&lt;p&gt;预校验从 Java6 开始被支持，Java6 上是可选的，Java7 以上是必须的，但是 Android 上是可选的，在我们的工程里，关闭了这个选项，这也是官方推荐的，因此暂时也就没有了解。&lt;/p&gt;
&lt;p&gt;这样之后，我们会看到，我们的主要工作主要集中在 shink、optimize 和 obfuscate 这三项上。&lt;/p&gt;
&lt;h1 id=&quot;compile-VS-runtime&quot;&gt;&lt;a href=&quot;#compile-VS-runtime&quot; class=&quot;headerlink&quot; title=&quot;compile VS runtime&quot;&gt;&lt;/a&gt;compile VS runtime&lt;/h1&gt;&lt;p&gt;事实上，ProGuard 是会在编译过程中处理所有的类，因此，正常情况下，在编译过程中的 warning 信息是非常有用的，如果我们能处理掉在编译过程中所有的 warning 信息，那将会对整个 ProGuard 的工作有非常大的帮助。而且编译期的 warning 信息是非常容易解决的，根据提示将对应的类或类成员 keep 掉即可。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7x2wvb.com1.z0.glb.clouddn.com/proguard/20170102-3@2x.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;但是，既然这是正常情况下，就肯定有一些非正常情况，在插件化里，由于类的调用方式已经改变了，可能有大量的编译器依赖并不会被打进最终的 Apk 里，因此编译过程中的 warning 信息就几乎完全不可用了。所以，还是要从运行期入手，通过运行期的报错信息，来一点点地处理，这极其低效，然而在我的有限理解里却是最有效。&lt;/p&gt;
&lt;h1 id=&quot;产物&quot;&gt;&lt;a href=&quot;#产物&quot; class=&quot;headerlink&quot; title=&quot;产物&quot;&gt;&lt;/a&gt;产物&lt;/h1&gt;&lt;p&gt;经过 ProGuard 处理之后，会生成四个文件：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7x2wvb.com1.z0.glb.clouddn.com/proguard/20170102-4@2x.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;dump.txt 描述apk文件中所有类文件的内部结构&lt;/li&gt;
&lt;li&gt;mapping.txt 列出了类、方法、成员的原貌与混淆后的映射表。在收到错误报告时，可以用它翻译混淆后的堆栈信息。参数为 -printmapping。&lt;/li&gt;
&lt;li&gt;seeds.txt 列出未混淆的类与成员。参数为 -printseeds。&lt;/li&gt;
&lt;li&gt;usage.txt 列出从apk中清除的无用代码。参数为 -printusage。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;根据上面的解释，我们可以发现 mapping.txt、seeds.txt、usage.txt 对于我们的 ProGuard 工作是非常重要的。通过分析它们，我们可以扩大混淆范围，尽可能精准地确定混淆信息。&lt;/p&gt;
&lt;p&gt;ProGuard 提供了 &lt;strong&gt;ReTrace&lt;/strong&gt; 功能，也就是反混淆功能。混淆之后，堆栈信息会变得很难看懂，这时候就需要 ReTrace 出场了，通过 mapping.txt，可以还原被混淆后的堆栈信息。用起来也很简单，如下：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;java -jar retrace.jar [options...] mapping_file [stacktrace_file]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h1 id=&quot;工具&quot;&gt;&lt;a href=&quot;#工具&quot; class=&quot;headerlink&quot; title=&quot;工具&quot;&gt;&lt;/a&gt;工具&lt;/h1&gt;&lt;p&gt;一些反编译工具能够帮助我们更好地完成 ProGuard 工作，通过一些措施，使反编译工具失效，也能更好地达到保护 App 的目的。&lt;/p&gt;
&lt;h2 id=&quot;Jadx&quot;&gt;&lt;a href=&quot;#Jadx&quot; class=&quot;headerlink&quot; title=&quot;Jadx&quot;&gt;&lt;/a&gt;Jadx&lt;/h2&gt;&lt;p&gt;最常用的就是 &lt;a href=&quot;https://github.com/skylot/jadx&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Jadx&lt;/a&gt; 了，可以直接反编译 apk，apk 里的二进制 xml、dex 都可以被反编译出来，如下截图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7x2wvb.com1.z0.glb.clouddn.com/proguard/20170102-5@2x.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;但是 jadx 并不能反编译 jar 包和 dex 文件&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;其他的诸如 &lt;a href=&quot;https://github.com/pxb1988/dex2jar&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;dex2jar&lt;/a&gt;，&lt;a href=&quot;https://github.com/iBotPeaches/Apktool&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Apktool&lt;/a&gt;，&lt;a href=&quot;https://github.com/JesusFreke/smali&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;smali/baksmali&lt;/a&gt;，&lt;a href=&quot;https://bytecodeviewer.com/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;BytecodeViewer&lt;/a&gt; 等，也都不错，不过都不如 jadx 用起来简单。前三者也没有 GUI 工具，功能也不够丰富。&lt;/p&gt;
&lt;h2 id=&quot;BytecodeViewer&quot;&gt;&lt;a href=&quot;#BytecodeViewer&quot; class=&quot;headerlink&quot; title=&quot;BytecodeViewer&quot;&gt;&lt;/a&gt;BytecodeViewer&lt;/h2&gt;&lt;p&gt;值得一提的是 &lt;code&gt;BytecodeViewer&lt;/code&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;它像 jadx 一样，也提供了 GUI 工具；&lt;/li&gt;
&lt;li&gt;对于 Java 的反编译提供了更多种方案，理论上应该是几种工具里反编译最准确，可定制性也最强的；&lt;/li&gt;
&lt;li&gt;更新也很快；&lt;/li&gt;
&lt;li&gt;比 jadx 更强大的一点是，它还可以反编译 jar 和 dex；&lt;/li&gt;
&lt;li&gt;而且更加难能可贵的是，它不仅提供了 class 的反编译，还可以可视化看到 smali 代码（如下图）。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;http://7x2wvb.com1.z0.glb.clouddn.com/proguard/20170102-6@2x.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7x2wvb.com1.z0.glb.clouddn.com/proguard/20170102-7@2x.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;但是实际上它对 apk 的支持并不好，经常会出问题。而且对于&lt;strong&gt;插件化&lt;/strong&gt;方案来讲，它有一个致命的缺陷，就是不支持一个 apk 里存在多个&lt;code&gt;packageId&lt;/code&gt;，一旦 apk 里有多个 &lt;code&gt;packageId&lt;/code&gt;，工具就会 crash。&lt;/p&gt;
&lt;p&gt;除了这些专门针对 Android 的反编译工具之外，还有一些针对 Java 的反编译工具，也可以参考一下，如 CFR、Procyon/&lt;a href=&quot;https://github.com/deathmarine/Luyten&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;luyten&lt;/a&gt;，&lt;a href=&quot;https://github.com/java-decompiler/jd-gui/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;JD-GUI&lt;/a&gt; 等，前两者比 JD-GUI 更准确，也更强大稳定。&lt;/p&gt;
&lt;h1 id=&quot;源码解析&quot;&gt;&lt;a href=&quot;#源码解析&quot; class=&quot;headerlink&quot; title=&quot;源码解析&quot;&gt;&lt;/a&gt;源码解析&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;ProGuard &lt;/strong&gt;的源码主要分为几个部分：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如何读取输入的文件（readInput）？&lt;/li&gt;
&lt;li&gt;shink、optimize、obfuscate、preverify 如何处理文件（Android 新的编译工具 Jack 执行任务的过程已经包含了 ProGuard，说明 ProGuard 不仅能处理 class？存疑。）？&lt;/li&gt;
&lt;li&gt;如何将输入的文件与 ProGuard 参数组合（Configuration）？&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这里只是大致分析一下如何读取，obfuscate 如何工作，以及 ProGuard 的参数配置部分。optimize 代码量太大了，以后再慢慢看，preverify 项目里没用到，shink 要简单不少，因此这三部分就不作分析了。&lt;/p&gt;
&lt;h2 id=&quot;readInput&quot;&gt;&lt;a href=&quot;#readInput&quot; class=&quot;headerlink&quot; title=&quot;readInput&quot;&gt;&lt;/a&gt;readInput&lt;/h2&gt;&lt;p&gt;先找到 &lt;code&gt;ProGuard#main&lt;/code&gt; 方法，在这里经过一系列 check，调到 &lt;code&gt;readInput()&lt;/code&gt; 方法，然后实例化 &lt;code&gt;InputReader&lt;/code&gt;，并调用 &lt;code&gt;readInput(String, ClassPath, DataEntryReader)&lt;/code&gt;，通过循环遍历读取 &lt;code&gt;class path entry&lt;/code&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/**&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; * Reads the given input class path entry.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;readInput&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(String messagePrefix, ClassPathEntry classPathEntry, DataEntryReader dataEntryReader)&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;throws&lt;/span&gt; IOException &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;try&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// Create a reader that can unwrap jars, wars, ears, and zips.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        DataEntryReader reader =&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                DataEntryReaderFactory.createDataEntryReader(messagePrefix,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                        classPathEntry,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                        dataEntryReader);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// Create the data entry pump.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        DirectoryPump directoryPump = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; DirectoryPump(classPathEntry.getFile());&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// Pump the data entries into the reader.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        directoryPump.pumpDataEntries(reader);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125; &lt;span class=&quot;keyword&quot;&gt;catch&lt;/span&gt; (IOException ex) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;throw&lt;/span&gt; (IOException) &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; IOException(&lt;span class=&quot;string&quot;&gt;&quot;Can&#39;t read [&quot;&lt;/span&gt; + classPathEntry + &lt;span class=&quot;string&quot;&gt;&quot;] (&quot;&lt;/span&gt; + ex.getMessage() + &lt;span class=&quot;string&quot;&gt;&quot;)&quot;&lt;/span&gt;).initCause(ex);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;紧接着递归调用 &lt;code&gt;readFiles&lt;/code&gt; 方法，读取每一个文件&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/**&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; * Reads the given subdirectory recursively, applying the given DataEntryReader&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; * to all files that are encountered.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;readFiles&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(File file, DataEntryReader dataEntryReader)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;throws&lt;/span&gt; IOException &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// Pass the file data entry to the reader.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    dataEntryReader.read(&lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; FileDataEntry(directory, file));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (file.isDirectory()) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// Recurse into the subdirectory.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        File[] listedFiles = file.listFiles();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; index = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; index &amp;lt; listedFiles.length; index++) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            File listedFile = listedFiles[index];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;try&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                readFiles(listedFile, dataEntryReader);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125; &lt;span class=&quot;keyword&quot;&gt;catch&lt;/span&gt; (IOException e) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;throw&lt;/span&gt; (IOException) &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; IOException(&lt;span class=&quot;string&quot;&gt;&quot;Can&#39;t read [&quot;&lt;/span&gt; + listedFile.getName() + &lt;span class=&quot;string&quot;&gt;&quot;] (&quot;&lt;/span&gt; + e.getMessage() + &lt;span class=&quot;string&quot;&gt;&quot;)&quot;&lt;/span&gt;).initCause(e);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;由这里，我们可以看到，关键点在 &lt;code&gt;DataEntryReader&lt;/code&gt;，这是个接口，有不同的实现类，这会根据传入的 file 的不同，选择不同的实现类去实例化。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7x2wvb.com1.z0.glb.clouddn.com/proguard/20161220-8.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;以 ClassReader 为例，继续下面的分析&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// Implementations for DataEntryReader.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;read&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(DataEntry dataEntry)&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;throws&lt;/span&gt; IOException &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;try&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// Get the input stream.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        InputStream inputStream = dataEntry.getInputStream();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// Wrap it into a data input stream.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        DataInputStream dataInputStream = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; DataInputStream(inputStream);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// Create a Clazz representation.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        Clazz clazz;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (isLibrary) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            clazz = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; LibraryClass();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            clazz.accept(&lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; LibraryClassReader(dataInputStream, skipNonPublicLibraryClasses, skipNonPublicLibraryClassMembers));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            clazz = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; ProgramClass();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            clazz.accept(&lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; ProgramClassReader(dataInputStream));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// Apply the visitor, if we have a real class.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        String className = clazz.getName();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (className != &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (!dataEntry.getName().replace(File.pathSeparatorChar, ClassConstants.PACKAGE_SEPARATOR).equals(className + ClassConstants.CLASS_FILE_EXTENSION) &amp;amp;&amp;amp;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    warningPrinter != &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                warningPrinter.print(className,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                        &lt;span class=&quot;string&quot;&gt;&quot;Warning: class [&quot;&lt;/span&gt; + dataEntry.getName() + &lt;span class=&quot;string&quot;&gt;&quot;] unexpectedly contains class [&quot;&lt;/span&gt; + ClassUtil.externalClassName(className) + &lt;span class=&quot;string&quot;&gt;&quot;]&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            clazz.accept(classVisitor);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        dataEntry.closeInputStream();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125; &lt;span class=&quot;keyword&quot;&gt;catch&lt;/span&gt; (Exception ex) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;throw&lt;/span&gt; (IOException) &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; IOException(&lt;span class=&quot;string&quot;&gt;&quot;Can&#39;t process class [&quot;&lt;/span&gt; + dataEntry.getName() + &lt;span class=&quot;string&quot;&gt;&quot;] (&quot;&lt;/span&gt; + ex.getMessage() + &lt;span class=&quot;string&quot;&gt;&quot;)&quot;&lt;/span&gt;).initCause(ex);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;值得一提的是，在 ProGuard 源码里用了大量的&lt;strong&gt;装饰器模式&lt;/strong&gt;和&lt;strong&gt;访问者模式&lt;/strong&gt;，代码阅读起来还是有一些困难。&lt;/p&gt;
&lt;p&gt;在上面的代码里，&lt;code&gt;Clazz&lt;/code&gt; 作为一个 &lt;code&gt;Element（抽象元素）&lt;/code&gt;，其实现类  &lt;code&gt;LibraryClass&lt;/code&gt; 和 &lt;code&gt;ProgramClass&lt;/code&gt; 是 &lt;code&gt;ConcreteElement（具体元素）&lt;/code&gt;，&lt;code&gt;ClassVisitor&lt;/code&gt; 作为一个 &lt;code&gt;Visitor（抽象访问者）&lt;/code&gt;，其实现类 &lt;code&gt;ProgramClassReader&lt;/code&gt; 和 &lt;code&gt;LibraryClassReader&lt;/code&gt; 都是 &lt;code&gt;ConcreteVisitor（具体访问者）&lt;/code&gt;，元素调用 &lt;code&gt;accept&lt;/code&gt; 方法（需要传入参数访问者），而在元素的 accept 方法里（元素里还有诸多其他的业务方法），又调用了访问者的 &lt;code&gt;visitProgramClass(ProgramClass programClass)&lt;/code&gt; 或 &lt;code&gt;visitLibraryClass(LibraryClass libraryClass)&lt;/code&gt;方法，从而实现『双重分派』，这里实际上少了一个 &lt;code&gt;ObjectStructure（对象结构）&lt;/code&gt;的角色和增加删除元素的方法，对象结构是元素的集合。下面就是简单的图示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7x2wvb.com1.z0.glb.clouddn.com/proguard/20170102-8@2x.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;如果是完整的访问者模式，这里需要修改一下，增加对象结构，然后编译集合，这样就可以使每一个元素都调用到访问者的 accept 方法，再加上增加元素和删除元素的方法。如果新增加元素，只需要调用增加删除元素的方法即可，而无需修改其他代码。&lt;/p&gt;
&lt;h2 id=&quot;obfuscate-1&quot;&gt;&lt;a href=&quot;#obfuscate-1&quot; class=&quot;headerlink&quot; title=&quot;obfuscate&quot;&gt;&lt;/a&gt;obfuscate&lt;/h2&gt;&lt;p&gt;对访问者模式有一个大致了解之后，obfuscate 的代码也就不那么难读懂了。在这里 ClassPool 是元素，ClassPoolVistor 是访问者。调用 Obfuscator 的 execute 方法，在这个方法里就按照下面的步骤执行：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;先去 check 一下 keep 规则、applyMapping、printMapping 是否同时为空，同时为空就抛出异常，否则继续；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;清空 visitor 信息；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;根据类成员的名字是否要全局对应，如果是的话，就 link 所有的类，否则就 link 所有类里的非 private 方法，具体做法是：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;ClassVisitor memberInfoLinker = configuration.useUniqueClassMemberNames ? (ClassVisitor)&lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; AllMemberVisitor(&lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; MethodLinker()) : (ClassVisitor)&lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; BottomClassFilter(&lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; MethodLinker());&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;programClassPool.classesAccept(memberInfoLinker);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;libraryClassPool.classesAccept(memberInfoLinker);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;classesAccept&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(ClassVisitor classVisitor)&lt;/span&gt; &lt;/span&gt;&amp;#123; &lt;span class=&quot;comment&quot;&gt;//classesAccept 是 ClassPool 这个元素里的一个业务方法，而在这个方法里，又将 memberInfoLinker 作为一个访问者，通过循环遍历，处理每一个类。&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Iterator iterator = classes.values().iterator();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt; (iterator.hasNext()) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        Clazz clazz = (Clazz) iterator.next();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        clazz.accept(classVisitor);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;创建标记为 seed（参照上文的 seeds.txt） 的 visitor，并标记 seed；&lt;/p&gt;
&lt;figure class=&quot;highlight actionscript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;NameMarker nameMarker = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; NameMarker();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;ClassPoolVisitor classPoolvisitor =&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ClassSpecificationVisitorFactory.createClassPoolVisitor(configuration.keep,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                                                            nameMarker,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                                                            nameMarker,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                                                            &lt;span class=&quot;literal&quot;&gt;false&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                                                            &lt;span class=&quot;literal&quot;&gt;false&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                                                            &lt;span class=&quot;literal&quot;&gt;true&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 又是访问者模式&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;programClassPool.accept(classPoolvisitor);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;libraryClassPool.accept(classPoolvisitor);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;keep library 里的 class 和 library 里的 class member；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;keep 返回动态方法调用的类成员；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;标记需要被 keep 的 attributes；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;keep 方法的参数和参数类型；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;移除被标记为丢弃的 attitutes；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;applyMapping；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;为所有的类指定新的名字（应用混淆字典）；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;为所有的类成员指定新的名字；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;解决在替换名字过程中可能引起的冲突；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;如果有 warning 新的话，就打印 warning 信息；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;移除没有用到的常量。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这就是整个混淆的过程。以上步骤除了第一步的 check 之外，无一例外全都是通过访问者模式实现的。&lt;/p&gt;
&lt;h1 id=&quot;常见问题（runtime）&quot;&gt;&lt;a href=&quot;#常见问题（runtime）&quot; class=&quot;headerlink&quot; title=&quot;常见问题（runtime）&quot;&gt;&lt;/a&gt;常见问题（runtime）&lt;/h1&gt;&lt;p&gt;需要重点提及的一个问题就是因为&lt;strong&gt;间接依赖&lt;/strong&gt;，造成不该被混淆优化的类和类成员被混淆优化了。比如 Activity，Fragment 这种，类被打进了宿主里，其他模块引用的又是 BaseActivity 这种中间类，同时又没有通过 provided 去依赖，这样就会造成 Activity 被混淆了。实践过程中，有相当一部分问题都是这种原因造成的。我们现在的解决方案是，让所有的模块都 provided 了一份其他所有模块的 api，这样保证不会因为间接依赖而出问题，不过因为打包的时候会扫描所有的类，会造成编译速度会慢几秒钟。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;java.lang.ClassNotFoundException&lt;/p&gt;
&lt;p&gt;类找不到，keep 掉对应的类即可。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;java.lang.NoSuchMethodError&lt;/p&gt;
&lt;p&gt;方法找不到，keep 掉对应的方法即可。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Java.lang.UnsupportedOperationException: Required method xxx was not overridden&lt;/p&gt;
&lt;p&gt;方法没被重写，keep 掉对应的方法即可。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;java.lang.AbstractMethodError&lt;/p&gt;
&lt;p&gt;接口里方法和 new 出来的接口对象里实现的方法名不一致，需要保证它们是一致的。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;other&lt;/p&gt;
&lt;p&gt;其他问题，可以先把对应的类给 keep 掉，然后再去断点调试定位哪里出了问题。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;p&gt;这就是我做 ProGuard 相关的工作时的一些经验。ProGuard 的工作其实是很不容易做的，这最需要耐心，很多问题有时候经验本身会显得更重要。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;Android 里比较常见的混淆方案就是 &lt;a href=&quot;https://www.guardsquare.com/en/proguard&quot;&gt;ProGuard&lt;/a&gt; 和 &lt;a href=&quot;https://www.guardsquare.com/en/dexguard&quot;&gt;DexGuard&lt;/a&gt;，都是 GuardSquare 的产品，前者免费，后者收费；同时，GuardSquare 还推出了 iOS 的混淆方案 &lt;a href=&quot;https://www.guardsquare.com/en/ixguard&quot;&gt;iXGuard&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;我们用的方案是 ProGuard，因此这里的讨论只针对 ProGuard，源码见这里 &lt;a href=&quot;https://sourceforge.net/projects/proguard/&quot;&gt;https://sourceforge.net/projects/proguard/&lt;/a&gt; 。
    
    </summary>
    
      <category term="Android" scheme="http://www.easydone.cn/categories/Android/"/>
    
    
      <category term="Obfuscate" scheme="http://www.easydone.cn/tags/Obfuscate/"/>
    
      <category term="Optimize" scheme="http://www.easydone.cn/tags/Optimize/"/>
    
      <category term="Preverify" scheme="http://www.easydone.cn/tags/Preverify/"/>
    
      <category term="ProGuard" scheme="http://www.easydone.cn/tags/ProGuard/"/>
    
      <category term="Shink" scheme="http://www.easydone.cn/tags/Shink/"/>
    
  </entry>
  
  <entry>
    <title>一个不得已的解释</title>
    <link href="http://www.easydone.cn/2016/12/30/"/>
    <id>http://www.easydone.cn/2016/12/30/</id>
    <published>2016-12-30T12:32:52.000Z</published>
    <updated>2016-12-30T12:45:22.000Z</updated>
    
    <content type="html">&lt;p&gt;最近真是节奏不断…起因都是在朋友圈里说了一些人认为不该说的话。&lt;/p&gt;
&lt;p&gt;前两天被 drakeet 拉黑了，原因我也不想多说了。总之，当时反应是比较愕然，有那么一瞬间的失落，不过随即就消失了，慢慢地有一些生气一直到现在，不过并不在意，不会放在心上。&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;再接下来的一件事就有点让人懊恼了，而且因为牵涉到的人，也会觉着有一些伤心。当然，像我这么看得开的人，绝对不可能会因为已经无可挽回的与自己没什么关系的事情，而造成的这种不好的情绪持续太久。但是又不能看着事态进一步扩展，让不明真相的人产生误会。于情于理，这样的解释都必不可少。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;首先，我要说明的是，我认识的做 Android 的人真不多，所以说的 dodola 在 Android 方面的造诣在我认识的做 Android 的人里至少能排进前五，这是经过深思熟虑的，而且我不会改；&lt;/li&gt;
&lt;li&gt;其次在深度方面，我觉着 dodola 钻研的要比代码家、秋百万、hyman 要深，这也是没问题的。&lt;ul&gt;
&lt;li&gt;我没有加 hyman 的微信，只是有关注他的公众号和博客，鸿洋基础很扎实，能把问题讲的很清楚，对于技术的传播促进作用非常大，我也从他的博客里学到了很多，这是我认为他比 dodola 厉害的地方。而且我也经常在鸿洋公众号里留言，在知乎上也对吹了他一波。所以，不要再别有用心地说我黑鸿洋了，这个论据不扎实。&lt;/li&gt;
&lt;li&gt;秋百万，我跟他交流很少，微信上基本没说过话，但是我也没有黑他的动机。当初，他说要举办一个读书的活动，转发微博送书，还说希望可以做成大家一起参与的形式，我看到后，立马给他在微信上发了100块钱的红包。虽然，我觉着他的群太严肃，不适合我，然后退群了，但是他为社区做的事情，是我很佩服的。同时他的管理、组织能力非常强。这些点上，他比 dodola 要厉害很多。而且，我也在知乎上吹过秋百万，并且在有人黑他的时候我也是极力维护的。所以，不要再别有用心地说我黑秋百万了，这个论据不扎实。&lt;/li&gt;
&lt;li&gt;最后是代码家，毫无疑问，他根本不在意这样的事情。他的状态是我最欣赏的，也是我希望能够达到的。当然，他的技术是毋庸置疑的，非常厉害，真正的全栈（但是，在 Android 方面，我依然认为 dodola 比他钻研的要深）。他对待技术已经不再苛求，更多地去享受生活。人的一生里，有很多很重要的事情，远不止代码和技术本身。做自己喜欢做的事，永远不用担心因为无法坚持做一件事而无法精通，完全凭借兴趣去享受生活。这是一般人无法达到的。我都已经说到这种地步了，还会有人相信我在黑代码家吗？所以，不要再别有用心地说我黑代码家了，这个论据不扎实。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;我不喜欢把太多的时间花在社交上，我同样不喜欢这样的人，我虽然对技术追求不狂热，但是我认为这样整天把『我认识xxx大神』挂在嘴上的人，不值得深交。&lt;/p&gt;
&lt;p&gt;经常看到有人说要『做自己』，但是目力所及的全都是『人情赞』『人情吹』，你怎么『做自己』？『跪舔』是拿来开玩笑的，那么认真干什么？&lt;/p&gt;
&lt;p&gt;最后，再说一次，生活里有很多重要的事情可以去做，远不止代码和技术本身，况且这几天的事情，让我深深地感受到『技术单纯，但是做技术的人并不单纯』。做自己喜欢做的事，永远不要担心因为无法坚持做一件事而无法精通，完全凭借兴趣去享受生活。这样的生活很有意义。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;最近真是节奏不断…起因都是在朋友圈里说了一些人认为不该说的话。&lt;/p&gt;
&lt;p&gt;前两天被 drakeet 拉黑了，原因我也不想多说了。总之，当时反应是比较愕然，有那么一瞬间的失落，不过随即就消失了，慢慢地有一些生气一直到现在，不过并不在意，不会放在心上。
    
    </summary>
    
      <category term="随笔" scheme="http://www.easydone.cn/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="解释" scheme="http://www.easydone.cn/tags/%E8%A7%A3%E9%87%8A/"/>
    
  </entry>
  
  <entry>
    <title>这一年</title>
    <link href="http://www.easydone.cn/2016/12/25/"/>
    <id>http://www.easydone.cn/2016/12/25/</id>
    <published>2016-12-25T14:46:45.000Z</published>
    <updated>2016-12-25T14:46:56.000Z</updated>
    
    <content type="html">&lt;p&gt;前些天，看了电影『驴得水』，朋友跟我讲，很心疼张一曼，我也回了个『嗯，心疼』，然后又接了句『也心疼周铁男』。在听到枪响之前，这是我最喜欢的一个角色，年轻、莽撞、单纯，枪响之后，这个人立马变成了自己曾经讨厌的样子。最近一直在问自己：忙忙碌碌一整年，如今的自己是个什么样子？&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;去年年底，确定了加入口袋，然后休息了一段时间，今年过完春节就直接过来了。如今再审视当初的决定，我很庆幸。一整年的时间里，懈怠过多少次，就被鼓励过多少次，也就成长了多少次。假如是放在一年前，我可能会觉着自己做不到现在这样。有时候我会想，假如没有那么多次的懈怠，而是一直奋不顾身的往前冲，是不是结果会更好一点？以我的性格，即便知道结果会更好，恐怕依然会有那么多次的懈怠。这一年的经历，我更加确信这是一个很好的团队，有最好的 HR，有最好的领导，有最好的伙伴。也正是因为这些亦师亦友的同事们，才会允许我有这么多的懈怠。&lt;/p&gt;
&lt;p&gt;如果只是看这过去的一年，也许还可以沾沾自喜。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;到现在，整个项目的平台化改造基本完成，还剩下一些细枝末节的工作，都是一些体力活，以后会慢慢完善。 &lt;/li&gt;
&lt;li&gt;工作之余看了15本书，有传记类、小说类、管理类、心理类…比之以前，通过读书开始更多的思考宏观层面的东西了。&lt;/li&gt;
&lt;li&gt;举行了婚礼，亲朋好友也终于都放心了。作为一个男人，终于下决心去承担自己应该承担的那份责任。&lt;/li&gt;
&lt;li&gt;被折磨了十多年鼻炎，终于下决心去做了手术，虽然没有彻底治愈，不过总算是有效果。&lt;/li&gt;
&lt;li&gt;看了两场很早之前就想去的奶茶刘若英的演唱会，而且第一场是很有纪念意义的这一年的第一天。&lt;/li&gt;
&lt;li&gt;认识了喜欢同样类型电影的新朋友，我想这会是一辈子的财富吧。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;然而在这一年的最后几天，依然开始莫名其妙地很焦虑，回想一下，多年以前自己的理想，如今越来越看不清楚。事到如今，终究是一事无成，没有长成十五岁的自己讨厌的样子，却也没有成为理想中的大人。在北京这样一个冰冷的城市的冰冷的冬天里，面对这样的自己，难免会让自己这模糊的未来显得更加虚无缥缈。我是一个很传统的人，从小到大，都在极力克制自己，在我所有的已经形成的观念里，努力守规矩是一件很重要的事，克制会创造幸福。我不喜欢迟到，不喜欢不上进，不喜欢把大量精力都浪费在社交上，不喜欢把太多的时间都浪费在睡觉上，不喜欢桌子上堆好多垃圾…然而即便如此，这么久了，还是一无所成。在中国这样一个如此重视家这个概念的国度里，我这样一个传统观念如此根深蒂固的人，就这样一直在离家几千里之外的地方飘啊飘啊飘啊…儿行千里母担忧啊，在几千里外的家里，越来越苍老的父亲母亲，还要承受为几千里之外的儿子的平安健康提心吊胆。这实在太让人沮丧了。每每念及于此，总会忍不住悲伤起来，有时候会觉着自己是不是一直都是错的…&lt;/p&gt;
&lt;p&gt;也许这一生就这样了吧。再往下想，正如即便事先知道面对困难不去懈怠会有更好的结果，我还是会懈怠一样，选择了这样的人生，已然成为了这样的自己，注定要在焦虑和安逸中度过每一个春夏秋冬，也许更应该放宽心，至少让家里的父母对自己放心，让自己不至于在畏首畏尾里蹉跎岁月。『我从来不曾爱过一个人会比海更深，奢求太多也注定无济于事』。经常会劝别人，既来之，则安之，要放宽心，这事没那么严重。这样放之天下皆准的道理，我讲起来最是得心应手。而我这么克制的人，当然也不可能会一直焦虑下去。不是每个人都能成为自己理想中的大人。比去年的这个时候，我让家人朋友更放心了，这就是我啊。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;前些天，看了电影『驴得水』，朋友跟我讲，很心疼张一曼，我也回了个『嗯，心疼』，然后又接了句『也心疼周铁男』。在听到枪响之前，这是我最喜欢的一个角色，年轻、莽撞、单纯，枪响之后，这个人立马变成了自己曾经讨厌的样子。最近一直在问自己：忙忙碌碌一整年，如今的自己是个什么样子？
    
    </summary>
    
      <category term="随笔" scheme="http://www.easydone.cn/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="克制" scheme="http://www.easydone.cn/tags/%E5%85%8B%E5%88%B6/"/>
    
      <category term="焦虑" scheme="http://www.easydone.cn/tags/%E7%84%A6%E8%99%91/"/>
    
      <category term="责任" scheme="http://www.easydone.cn/tags/%E8%B4%A3%E4%BB%BB/"/>
    
  </entry>
  
  <entry>
    <title>故事要开始了吗</title>
    <link href="http://www.easydone.cn/2016/12/08/"/>
    <id>http://www.easydone.cn/2016/12/08/</id>
    <published>2016-12-08T09:46:02.000Z</published>
    <updated>2016-12-08T12:22:35.000Z</updated>
    
    <content type="html">&lt;p&gt;如何开办一个开发者大会？开发者们从来都不要求 CSDN、QCON 之流能够有多么高尚的追求，甚至极尽包容乃至允许平庸，然而无处不散发着的鸡贼气息，着实让人扫兴。今天去参加了 Google Developer Day 。无论从哪个角度看，Google 都为国内众多组织机构做了一个最好的示范，一家企业的价值观在整个大会的方方面面，每一个细节都体现的淋漓尽致。&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;最让人惊喜、最激动人心的莫过于 &lt;a href=&quot;developers.google.cn&quot;&gt;developers.google.cn&lt;/a&gt; 的回归，虽然对于搜索、Play 等服务在国内的落地不能盲目乐观，甚至仍然看不到任何希望，但是这已然成为众多开发者欢欣雀跃甚至热泪盈眶的事情。事实上，在技术开发领域，Google 一直都在，技术本身是没有界限的，即便在之前不翻墙无法访问 Google 的 developers 网站，Google 也一直在默默地做着自己的能做的工作，这也是为什么我们能在官网看到越来越多的中文文档。而如今，再也不用翻墙就可以看各种开发文档，下载各种开发工具，甚至有不少服务也已经可以更轻松地接入。有人已经不禁哼出来了：终于等到你，还好我没放弃…&lt;/p&gt;
&lt;p&gt;台上讲演的任何一位 Google 工程师，都没有无脑吹嘘自己现在做的工作多么多么厉害，也没有为自己所做出的成绩而沾沾自喜，而是非常的坦诚，遇到自己不会的东西，就说不会，讲到 Google 一而再地自己打自己脸，也会调侃戏谑，整个过程非常的轻松愉快，像是在聊天。还有很重要的一点，也是让国内众多所谓的xx大会汗颜的，那就是全部的讲演全程无广告。Google 当然有自己的 AdWords 和 Admob，但是 AdWords 和 Admob只是偌大的展区里的两个小展台，在面向开发者的主会场和分会场是完全没有广告的，而面向运营的 Ads 会场只有一个，更何况这是切实地在为中国的团队提供更加可行、有效、有价值的海外推广方案。而国内众多厂商，正式凭借 Google 在国内的提供的服务，走出了国门，在海外大展拳脚。&lt;/p&gt;
&lt;p&gt;还有不得不提的就是午餐供应。要知道，这是一场完全免费的大会，除了 Google 自己的社交平台账号，几乎没有做任何宣传，仍然吸引了非常多的人来参加，然而 Google 并没有因为如此多的人，而且没有任何门票收入，就降低对午餐的要求。我不知道 Google 自己的餐厅是不是也是同样的高大上，但是这午餐真的是惊到我了，我只能说：实在是太棒了！想想之前花了几千块钱买一张 CSDN、QCON 的票，听了一整天的广告，结果中午就给一盒饭，甚至有时候连吃饭的地方都没有，找个地儿蹲下就对付了。我的天呐，这都 21 世纪了，还能这样糊弄人，这是在欺负人没见过世面吗？&lt;/p&gt;
&lt;p&gt;跟 Google 这样的企业处在同一个时代，是多么幸运的一件事；能用 Google 提供的技术做出来产品，是多么幸运的一件事；能够用 Google 的理念去影响更多的人，是多么幸运的一件事。这仍然是一家会犯错、会作恶的企业，然而 Google 是如此的自由、真诚、伟大，以至于你可以永远对它充满期待。&lt;/p&gt;
&lt;p&gt;它总会给你惊喜。也许关于 Google 在中国的故事从来都不存在什么时候开始的问题，关于 Google 中国，故事一直都在继续。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;如何开办一个开发者大会？开发者们从来都不要求 CSDN、QCON 之流能够有多么高尚的追求，甚至极尽包容乃至允许平庸，然而无处不散发着的鸡贼气息，着实让人扫兴。今天去参加了 Google Developer Day 。无论从哪个角度看，Google 都为国内众多组织机构做了一个最好的示范，一家企业的价值观在整个大会的方方面面，每一个细节都体现的淋漓尽致。
    
    </summary>
    
      <category term="随笔" scheme="http://www.easydone.cn/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="Google" scheme="http://www.easydone.cn/tags/Google/"/>
    
  </entry>
  
  <entry>
    <title>关于oasis的组件化思想的一些思考</title>
    <link href="http://www.easydone.cn/2016/09/25/"/>
    <id>http://www.easydone.cn/2016/09/25/</id>
    <published>2016-09-25T11:43:36.000Z</published>
    <updated>2016-12-08T11:21:04.000Z</updated>
    
    <content type="html">&lt;p&gt;插件化技术发展到现在其实已经很成熟了，但是相应的问题，如果没有真正地去实践过，根本不了解其中有多少问题，会牵涉到多少技术细节，多少被外人膜拜的外表光鲜的技术大牛都被『插件化』这三个字折磨地死去活来，这对于 Android 整个生态的损害也让人无法忽视。&lt;/p&gt;
&lt;p&gt;昨天的 MDCC ，冯森林老师提出了一个很有意思的思路『组件化』。&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;我们首先要想一下，我们做插件化的目的是什么？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;为了满足产品随时上线的需求？&lt;/li&gt;
&lt;li&gt;为了修复因为我们对自己要求不严格而写出来的 bug ？&lt;/li&gt;
&lt;li&gt;为了向人炫耀自己的技术实力？&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;很抱歉，如果是为了这些目的，那就真的太对不起自己是『开发者』这个如此高逼格的身份了。&lt;/p&gt;
&lt;p&gt;做插件化真正的目的：是为了去适应并行开发，是为了解耦各个模块，是为了避免模块之间的交叉依赖，是为了加快编译速度，从而提高并行开发效率。&lt;/p&gt;
&lt;p&gt;明确了这些，我们再来看插件化的结果，每个模块都支持独立运行测试，分为稳定的 release 版本和不稳定的 snapshot 版本，每个模块都高度解耦，没有交叉依赖，不会出现一个模块依赖了另一个模块，其中一个人改了这个模块的代码，对另一个模块造成影响。这时候，我们再看冯老师的『组件化』思想。&lt;/p&gt;
&lt;p&gt;那么这个『组件化』是什么意思呢？我说下我自己的理解，可能不对，还请指教：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;通过 gradle 配置的方式，将打 debug 包和 release 包分开。这样会有一个好处，开发一个模块，在 debug 的时候，可以打成一个 apk ，独立运行测试，可以完全独立于整个宿主 APP 的其他所有组件；待到要打 release 包的时候，再把这个模块作为一个 library ，打成 aar ，作为整个宿主 APP 的一部分。而 debug 和 release 的切换都是通过 gradle 配置，可以做到无缝切换。至于模块之间的跳转，可以用别名的方式，而不是用 Activity 和 Fragment 类名。这样所有的模块和宿主 APP 都是完全解耦的，彻底解决了并行开发的可能造成的交叉依赖等问题。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;按照这个思路，我们再来看看一些其他的细节：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;在 Android 里有一个比较爽的一点是，作为 library 的时候，aar 里的引用依赖，在宿主 Application 里也有同样的引用依赖，并不会打包两份到宿主 Application 里；&lt;/li&gt;
&lt;li&gt;模块之间的跳转，除了使用别名的方式，我能想到的还有另外一种方式，同样是通过 gradle 脚本，将跳转用到的类打成一个 jar ，作为一个 API 服务提供给其他模块作为编译期依赖（provided）引入；&lt;/li&gt;
&lt;li&gt;各个 library 在 debug 的时候作为 apk ，要独立打包运行测试，这时就需要有一个启动 Activity ，而 library 是不需要的，我的想法是放置两个 AndroidManifest.xml ，使用 sourceSets 分别在 debug 和 release 的时候加载不同的 AndroidManifest.xml 。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;怎么样？看上去是不是很像插件化 Atlas ？然而这个方案没有任何『黑科技』，不牵涉任何 hook ，跟 Atlas 的区别就是无需关心不同的 Context ，无需再关心类、资源怎么去加载，无需关心 Context 的安全问题，无需关心不同机型的兼容适配…技术成本可能连 Atlas 的十分之一都不到！&lt;/p&gt;
&lt;p&gt;感兴趣的话，可以看看这个 slide 分享，地址在这儿&lt;a href=&quot;http://www.slideshare.net/oasisfeng/from-containerization-to-modularity&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;from-containerization-to-modularity&lt;/a&gt;，我也写了个小 sample 去实现这个想法&lt;a href=&quot;GitHub - liangzhitao/ComponentizationApp&quot;&gt;ComponentizationApp&lt;/a&gt;。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;插件化技术发展到现在其实已经很成熟了，但是相应的问题，如果没有真正地去实践过，根本不了解其中有多少问题，会牵涉到多少技术细节，多少被外人膜拜的外表光鲜的技术大牛都被『插件化』这三个字折磨地死去活来，这对于 Android 整个生态的损害也让人无法忽视。&lt;/p&gt;
&lt;p&gt;昨天的 MDCC ，冯森林老师提出了一个很有意思的思路『组件化』。
    
    </summary>
    
      <category term="Android" scheme="http://www.easydone.cn/categories/Android/"/>
    
    
      <category term="Android" scheme="http://www.easydone.cn/tags/Android/"/>
    
      <category term="Gradle" scheme="http://www.easydone.cn/tags/Gradle/"/>
    
      <category term="插件化" scheme="http://www.easydone.cn/tags/%E6%8F%92%E4%BB%B6%E5%8C%96/"/>
    
      <category term="组件化" scheme="http://www.easydone.cn/tags/%E7%BB%84%E4%BB%B6%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>关于Android插件化的细枝末节</title>
    <link href="http://www.easydone.cn/2016/07/24/"/>
    <id>http://www.easydone.cn/2016/07/24/</id>
    <published>2016-07-24T07:59:55.000Z</published>
    <updated>2016-07-24T13:56:39.000Z</updated>
    
    <content type="html">&lt;p&gt;最近一直在做插件化相关的工作。现在最常见的方案就是来自阿里的 Atlas 和 360 的 DroidPlugin 了。按照我的理解，对于当前的大多数应用来讲，可能 Atlas 会更适合一些，因为它允许插件与宿主之间，甚至是插件之间可以有互动；而 DroidPlugin 的思想会更先进，可想象空间更大一些，理论上它可以启动任何一个第三方应用，比如虚拟化，可参照物就是 LBE 的平行空间。&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;Atlas 并没有开源，&lt;a href=&quot;https://github.com/DroidPluginTeam/DroidPlugin&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;DroidPlugin&lt;/a&gt; 已开源，我们现在采用的方案是基于 Atlas 的，有兴趣的可以看看 &lt;a href=&quot;https://github.com/bunnyblue/ACDD&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;ACDD&lt;/a&gt; ，核心思想都是一样。&lt;/p&gt;
&lt;p&gt;不管是插件化，还是热补丁，现在的方案都比较多，相应方案在 GitHub 上也都能找得到 demo ，Google 一下，也有不少文章，然而停留在 demo 和文章介绍阶段，始终与实际的生产开发有较大的距离，尤其是大部分文章还只是纸上谈兵，写文章的十之七八恐怕都没有真正的在自己的应用里实践过，而插件化最困难的部分就是实践过程中遇到各种细节和适配问题，还有对当前开发模式的影响也是怎么都绕不过去的问题。下面我大致列一下我们在实践过程中遇到的一些问题。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;插件怎么去引用宿主里的类？&lt;/li&gt;
&lt;li&gt;插件怎么去引用宿主的资源？&lt;/li&gt;
&lt;li&gt;插件化要给每个插件进行资源分段，该如何进行资源分段？&lt;/li&gt;
&lt;li&gt;为了让业务的同学更容易接受，怎么处理宿主的类和资源？&lt;/li&gt;
&lt;li&gt;在引用宿主的资源的时候，默认可用的 context 在插件化里是否依然可用？&lt;/li&gt;
&lt;li&gt;不同的资源类型，引用和处理方式是否相同？&lt;/li&gt;
&lt;li&gt;插件之间共用的一些类，是放在宿主里，还是在插件里开放出接口，该怎么样去考量？&lt;/li&gt;
&lt;li&gt;插件如何去开放接口，让其他插件引用？&lt;/li&gt;
&lt;li&gt;插件开放出了接口，其他插件又该怎样去引用？&lt;/li&gt;
&lt;li&gt;不同的插件都要引用同一个类和同一个资源，类和资源重复了该怎么办？&lt;/li&gt;
&lt;li&gt;加载各个插件时，怎么样知道各个插件的信息？&lt;/li&gt;
&lt;li&gt;插件版本该如何去管理？&lt;/li&gt;
&lt;li&gt;怎样实现 debug 和 release 开发的宿主和插件打包？&lt;/li&gt;
&lt;li&gt;应用启动时要加载那么多插件，怎么加速第一次启动？&lt;/li&gt;
&lt;li&gt;插件引用的宿主的类和资源发生改变，难道每次都要去每个插件里手动修改吗？&lt;/li&gt;
&lt;li&gt;四大组件的免注册是怎么回事？&lt;/li&gt;
&lt;li&gt;四大组件免注册了，是否还需要合并每个插件的 AndroidManifest ？&lt;/li&gt;
&lt;li&gt;在不允许手动拷贝的情况下，如何合并各个插件的 AndroidManifest ？&lt;/li&gt;
&lt;li&gt;宿主的方法数超过 65535 了，该怎么办？&lt;/li&gt;
&lt;li&gt;混淆问题怎么去处理？&lt;/li&gt;
&lt;li&gt;适配，还是适配。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;实际操作中，因为对开发的影响是不可避免的，多亏了有 gradle ，通过定制 gradle 脚本，插件，甚至是 SDK 组件，很多事情我们可以做到自动化，当然，凡事有利就有弊，在这个过程中，会发现相当多的正常开发遇不到的 gradle 的『bug』，因此，假如 gradle 玩不转，会有很多麻烦。目前大致能想到的就这么多，以后有想到了再补充吧。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;最近一直在做插件化相关的工作。现在最常见的方案就是来自阿里的 Atlas 和 360 的 DroidPlugin 了。按照我的理解，对于当前的大多数应用来讲，可能 Atlas 会更适合一些，因为它允许插件与宿主之间，甚至是插件之间可以有互动；而 DroidPlugin 的思想会更先进，可想象空间更大一些，理论上它可以启动任何一个第三方应用，比如虚拟化，可参照物就是 LBE 的平行空间。
    
    </summary>
    
      <category term="Android" scheme="http://www.easydone.cn/categories/Android/"/>
    
    
      <category term="Android" scheme="http://www.easydone.cn/tags/Android/"/>
    
      <category term="Plugin" scheme="http://www.easydone.cn/tags/Plugin/"/>
    
  </entry>
  
  <entry>
    <title>Scala之旅-函数式编程简介</title>
    <link href="http://www.easydone.cn/2016/05/12/"/>
    <id>http://www.easydone.cn/2016/05/12/</id>
    <published>2016-05-12T15:43:44.000Z</published>
    <updated>2016-05-12T16:19:32.000Z</updated>
    
    <content type="html">&lt;h2 id=&quot;函数式编程的特点&quot;&gt;&lt;a href=&quot;#函数式编程的特点&quot; class=&quot;headerlink&quot; title=&quot;函数式编程的特点&quot;&gt;&lt;/a&gt;函数式编程的特点&lt;/h2&gt;&lt;p&gt;Scalable 可伸缩。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;纯函数（Pure Function），或函数的纯粹性（Purity），没有副作用（Side Effect）。&lt;br&gt;副作用指状态的变化（mutation）。如修改全局变量（x+=y），抛出异常，IO读写，调用有副作用的函数。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;引用透明（Referential Transparency）。对于相同的输入，总是能得到相同的输出。&lt;br&gt;如果 f(x) 的参数 x 和函数体都是引用透明的，那么函数 f 就是纯函数。（反例：append）&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;&lt;strong&gt;函数是第一等公民（First-class Function）&lt;/strong&gt;，函数、对象、变量、类同一级，可以把函数当作参数传给另一个函数，也可以把函数当作返回值返回，也可以在函数体里定义函数等。&lt;/p&gt;
&lt;p&gt;一切都是计算，函数式编程中只有表达式，变量、函数都是表达式。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;高阶函数（High order Function）&lt;/strong&gt; 指把函数当作一个函数的输入或一个函数的输出。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;闭包（Closure）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;表达式求值策略&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;严格求值（Call By Value）和非严格求值（Call By Name）。&lt;/p&gt;
&lt;p&gt;惰性求值（Lazy Evaluation）定义时不求值，第一次使用时才求值。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;递归函数（Recursive Function）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;函数式编程里没有循环，使用递归实现循环。（性能）&lt;/p&gt;
&lt;p&gt;调优递归→尾递归（Tail Recursion）。&lt;/p&gt;
&lt;h2 id=&quot;优点&quot;&gt;&lt;a href=&quot;#优点&quot; class=&quot;headerlink&quot; title=&quot;优点&quot;&gt;&lt;/a&gt;优点&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;生产效率高；&lt;/li&gt;
&lt;li&gt;易于推理（Reasoning），对于给定的输入，总能得到确定的输出，调试方便；&lt;/li&gt;
&lt;li&gt;并行编程，适用于多核计算，云计算（Spark），在多个节点上运算，得到的结果都是相同的；&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;环境&quot;&gt;&lt;a href=&quot;#环境&quot; class=&quot;headerlink&quot; title=&quot;环境&quot;&gt;&lt;/a&gt;环境&lt;/h2&gt;&lt;p&gt;安装&lt;br&gt;&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;brew install scala&amp;#10;brew install sbt&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;终端编程&lt;br&gt;&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;scala&amp;#10;sbt console&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;函数式编程的特点&quot;&gt;&lt;a href=&quot;#函数式编程的特点&quot; class=&quot;headerlink&quot; title=&quot;函数式编程的特点&quot;&gt;&lt;/a&gt;函数式编程的特点&lt;/h2&gt;&lt;p&gt;Scalable 可伸缩。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;纯函数（Pure Function），或函数的纯粹性（Purity），没有副作用（Side Effect）。&lt;br&gt;副作用指状态的变化（mutation）。如修改全局变量（x+=y），抛出异常，IO读写，调用有副作用的函数。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;引用透明（Referential Transparency）。对于相同的输入，总是能得到相同的输出。&lt;br&gt;如果 f(x) 的参数 x 和函数体都是引用透明的，那么函数 f 就是纯函数。（反例：append）&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="Scala" scheme="http://www.easydone.cn/categories/Scala/"/>
    
    
      <category term="Scala" scheme="http://www.easydone.cn/tags/Scala/"/>
    
  </entry>
  
  <entry>
    <title>所有的期待</title>
    <link href="http://www.easydone.cn/2016/05/08/"/>
    <id>http://www.easydone.cn/2016/05/08/</id>
    <published>2016-05-08T11:18:48.000Z</published>
    <updated>2016-05-09T00:09:06.000Z</updated>
    
    <content type="html">&lt;p&gt;五一回家，我办了婚礼。其实对于来说，这个仪式有没有倒并没有什么所谓，不过这总归是家里人的一桩心愿，了却了这桩心愿，以后的事才能真正集中精力去做其他的事情嘛。&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;农村办婚礼，总是会有这样那样的习俗。不过基本上也都是家里人在忙，我自己除了当天和前一天，其他时候倒真没觉着累。亲朋好友，邻里乡亲，平常我不在家，也都见不着，甚至很多都已经生疏了，不记得名字和关系了，也都来帮忙了。中国人讲究人情关系，在大城市里，可能这人情关系总少不了蝇营狗苟，而在农村老家里，虽然也会有这样那样的市井甚至低俗小气，但总的来说，更多时候还是温情多一些，尤其是在邻里遇到红白事的时候。&lt;/p&gt;
&lt;p&gt;因为我们是过年的时候就定了要在五一办喜事，那会儿，就有不少或亲或不亲的乡里乡亲们给我家里送钱，毕竟娶媳妇儿要花不少钱嘛。听我爸妈讲，我的一位爷爷家里年轻人都不在家，也好久没回来过了，他平时只靠扫大街度日，一个月只有四五百块的工资，可还是给我们送过来1000块钱。还有另一位奶奶，也是孩子都不在家，平时和老伴儿过日子，以前老伴儿没生病的时候还可以出去打工，她负责家里的田地，老伴儿现在瘫痪在床，唯一的经济来源也没了，她只好捡破烂挣钱，即便如此，还是给送来了50块钱礼金。&lt;/p&gt;
&lt;p&gt;按照习俗，婚礼的前一天中午，在院子里摆一个大猪头，作为新郎，要行三跪九叩之礼，算是拜天；晚上，给祖先灵位前摆上火盆，要上香，敬酒，同样也有三跪九叩，这是拜祖先。作为传统，它看上去确实不合时宜，甚至是落后，然而对于家里人，这样的仪式既是对过去的几十年的情感的片刻升华，又包涵了对未来可能会有的各种状况的祝福。礼毕的时候，司仪让我分别跟爸妈拥抱，我妈瞬间就哭了，拥抱完毕，我一扭头，发现二姑已成为泪人儿。不管在外面多么风光落魄，家人永远都在。&lt;/p&gt;
&lt;p&gt;婚礼当天，很开心还有几个朋友也到场了，他们都是从远方特意赶回来，只为这一天，还有个朋友作为来宾代表上台致辞，多年以来，身边的人形形色色，来来往往，能说的上心里话，放心地把自己全部交出去的始终就这么几个。在这样的日子里，那些相濡以沫的回忆更加弥足珍贵。未来的某些日子里，他们也都会有自己的家庭，我也会揣着同样的心情去参加他们的婚礼。这就是朋友啊。&lt;/p&gt;
&lt;p&gt;还是习俗，我要带着她要在一个台子上，对所有的长辈们叩首认亲，认亲完毕，整个仪式就基本完成了。最后，需要向所有的来宾敬酒。这样，整个婚礼就完了。我跟媳妇儿在一块儿快五年了，认识快八年了，都是初恋，走到现在说简单也不简单。在一起之前，彼此眼里都只有优秀，在一块儿的日子里，相互嫌弃直到成为夫妻。一起走过的日子，真正回忆起来，全都是点滴琐碎，当初掀起的心绪波澜，如今看来都是芝麻绿豆的小事情，想要为这个人生中最重要的一次结合找到一个值得大书特书的标志性事件，却发现怎么也找不到。原来我们是在一起平淡了这么长时间，如此理所当然就完成了彼此的身份转变。&lt;/p&gt;
&lt;p&gt;农村里的生活挺简单的，能好好活着，家里人没病没灾就好。平时闲了就聚个摊儿打扑克聊天，有富余的钱可以偶尔下一次管子，看着孩子们成家立业、传宗接代，老了可以抱着孙子孙女逗乐，这就是他们对生活所有的期待。这在城里人看来可能太平淡乏味，即便是我，回到家里一天没有 WiFi ，也会感觉到浑身不自在，而在家里人看来，生活本来就应该如此。习惯了在大城市里的快节奏，跟媳妇俩人每天只有晚上能见到面，一起吃饭，有时候可能会因为加班，一整天也说不上一句话，这样的日子，没人会不觉着累。一回到老家，就可以跟家人坐在一起，一天三顿饭都在一起吃。这种温馨，一年里也没几天，因此每次都显得那么珍贵，而这也是我对生活所有的期待。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;五一回家，我办了婚礼。其实对于来说，这个仪式有没有倒并没有什么所谓，不过这总归是家里人的一桩心愿，了却了这桩心愿，以后的事才能真正集中精力去做其他的事情嘛。
    
    </summary>
    
      <category term="随笔" scheme="http://www.easydone.cn/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="家人" scheme="http://www.easydone.cn/tags/%E5%AE%B6%E4%BA%BA/"/>
    
      <category term="生活" scheme="http://www.easydone.cn/tags/%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
  <entry>
    <title>当EventBus遇上RxJava</title>
    <link href="http://www.easydone.cn/2016/03/29/"/>
    <id>http://www.easydone.cn/2016/03/29/</id>
    <published>2016-03-29T13:26:48.000Z</published>
    <updated>2016-05-08T09:44:36.000Z</updated>
    
    <content type="html">&lt;h2 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h2&gt;&lt;p&gt;接触过 &lt;code&gt;EventBus&lt;/code&gt; 和 &lt;code&gt;RxJava&lt;/code&gt; 的都知道，可以用 &lt;code&gt;RxJava&lt;/code&gt; 来实现 &lt;code&gt;EventBus&lt;/code&gt;，网上随便一搜，就可以拿得到代码。但是究竟为什么可以这么做？却没有类似的文章作进一步的深度解析。（本文假定读者都已经了解 &lt;code&gt;EventBus&lt;/code&gt; 和 &lt;code&gt;RxJava&lt;/code&gt; 是什么，可以做什么。）&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;RxBus&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;volatile&lt;/span&gt; RxBus instance;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;final&lt;/span&gt; SerializedSubject&amp;lt;Object, Object&amp;gt; subject;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;RxBus&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        subject = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; SerializedSubject&amp;lt;&amp;gt;(PublishSubject.create());&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; RxBus &lt;span class=&quot;title&quot;&gt;getInstance&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (instance == &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;synchronized&lt;/span&gt; (RxBus.class) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (instance == &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    instance = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; RxBus();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; instance;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;post&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(Object object)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        subject.onNext(object);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt;  &amp;lt;T&amp;gt; &lt;span class=&quot;function&quot;&gt;Observable&amp;lt;T&amp;gt; &lt;span class=&quot;title&quot;&gt;toObservable&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;final&lt;/span&gt; Class&amp;lt;T&amp;gt; type)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; subject.ofType(type);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;hasObservers&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; subject.hasObservers();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;可以看到，代码非常简练，当 &lt;code&gt;RxJava&lt;/code&gt; 遇上 &lt;code&gt;EventBus&lt;/code&gt; ，居然会如此神奇~那么问题来了，为什么这段代码就可以实现 &lt;code&gt;EventBus&lt;/code&gt; 的功能？&lt;/p&gt;
&lt;p&gt;要搞明白这几个问题，我们得弄清楚这些东西。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;EventBus&lt;/code&gt; 是如何实现的？&lt;/li&gt;
&lt;li&gt;&lt;code&gt;RxJava&lt;/code&gt; 满足了实现 &lt;code&gt;EventBus&lt;/code&gt; 的哪些条件？&lt;/li&gt;
&lt;li&gt;如何用 &lt;code&gt;RxJava&lt;/code&gt; 去封装一个 &lt;code&gt;EventBus&lt;/code&gt; ？&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;EventBus工作流程&quot;&gt;&lt;a href=&quot;#EventBus工作流程&quot; class=&quot;headerlink&quot; title=&quot;EventBus工作流程&quot;&gt;&lt;/a&gt;&lt;code&gt;EventBus&lt;/code&gt;工作流程&lt;/h2&gt;&lt;p&gt;简单讲，事件总线，顾名思义，分为两个概念，一个事件，即 Event ，一个总线，即 Bus ，这是在整个 APP 里一种规范地传递事件的方式。作为独立于项目里各个模块的 Application 级别的存在，可以很好地用来程序的解耦。使用大致有四个步骤：注册→发送→接收→取消注册。具体的源码分析，可以参看 codeKK 上 &lt;a href=&quot;http://www.trinea.cn/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Trinea&lt;/a&gt; 的 &lt;a href=&quot;http://a.codekk.com/detail/Android/Trinea/EventBus%20%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;EventBus源码解析&lt;/a&gt; 和 &lt;a href=&quot;http://www.kymjs.com/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;kymjs张涛&lt;/a&gt; 的 &lt;a href=&quot;http://kymjs.com/column/resourcecode.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;EventBus源码研读&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;更重要的一点，&lt;code&gt;RxBus&lt;/code&gt; 的重点应该在 &lt;code&gt;Bus&lt;/code&gt; 上，而不是 &lt;code&gt;RxJava&lt;/code&gt; 上。用 &lt;code&gt;RxJava&lt;/code&gt; 去实现 &lt;code&gt;EventBus&lt;/code&gt; 的思想。因此，应该把分析 &lt;code&gt;EventBus&lt;/code&gt; 作为一个重点。&lt;/p&gt;
&lt;p&gt;我们来看看要实现一个 &lt;code&gt;EventBus&lt;/code&gt; 需要满足什么条件。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;获取一个 &lt;code&gt;EventBus&lt;/code&gt; 实例，可以用单例，也可以用 &lt;code&gt;Builder&lt;/code&gt;；&lt;/li&gt;
&lt;li&gt;注册 &lt;code&gt;EventBus&lt;/code&gt; 和取消注册 &lt;code&gt;EventBus&lt;/code&gt;；&lt;/li&gt;
&lt;li&gt;发送和接收事件的方法。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;RxJava-amp-amp-EventBus&quot;&gt;&lt;a href=&quot;#RxJava-amp-amp-EventBus&quot; class=&quot;headerlink&quot; title=&quot;RxJava &amp;amp;&amp;amp; EventBus&quot;&gt;&lt;/a&gt;&lt;code&gt;RxJava&lt;/code&gt; &amp;amp;&amp;amp; &lt;code&gt;EventBus&lt;/code&gt;&lt;/h2&gt;&lt;p&gt;要实现 &lt;code&gt;EventBus&lt;/code&gt; 需要满足的条件，在 &lt;code&gt;RxJava&lt;/code&gt; 里是如何体现的呢？&lt;/p&gt;
&lt;p&gt;首先我们需要明确的是，&lt;code&gt;EventBus&lt;/code&gt; 里都有哪些角色：&lt;code&gt;Event&lt;/code&gt;、&lt;code&gt;Subscriber&lt;/code&gt;、&lt;code&gt;Publisher&lt;/code&gt;，也就是说需要&lt;code&gt;Event&lt;/code&gt;、&lt;code&gt;Observer&lt;/code&gt;、&lt;code&gt;Observable&lt;/code&gt;，Event 自不必说，在 &lt;code&gt;RxJava&lt;/code&gt; 里既能充当&lt;code&gt;Observer&lt;/code&gt;，又能充当&lt;code&gt;Observable&lt;/code&gt;的对象就是 &lt;code&gt;Subject&lt;/code&gt;，而 &lt;code&gt;Subject&lt;/code&gt; 是线程非安全的，我们要构造一个线程安全的 &lt;code&gt;Subject&lt;/code&gt; ，需要用到它的子类 &lt;code&gt;SerializedSubject&lt;/code&gt;，而实际使用的时候，我们的观察者只需要订阅发生之后的，来自 &lt;code&gt;Observable&lt;/code&gt; 的数据，因此还需要给 &lt;code&gt;SerializedSubject&lt;/code&gt; 传入 &lt;code&gt;PublishSubject&lt;/code&gt; 作为参数。&lt;/p&gt;
&lt;h3 id=&quot;获取Bus实例&quot;&gt;&lt;a href=&quot;#获取Bus实例&quot; class=&quot;headerlink&quot; title=&quot;获取Bus实例&quot;&gt;&lt;/a&gt;获取&lt;code&gt;Bus&lt;/code&gt;实例&lt;/h3&gt;&lt;p&gt;一个单例即可，当然，&lt;code&gt;EventBus&lt;/code&gt; 还提供了使用 &lt;code&gt;Builder&lt;/code&gt; 创建实例的方法，可根据具体情况自行实现；&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;volatile&lt;/span&gt; RxBus instance;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;RxBus&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	subject = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; SerializedSubject&amp;lt;&amp;gt;(PublishSubject.create());&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; RxBus &lt;span class=&quot;title&quot;&gt;getInstance&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (instance == &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;synchronized&lt;/span&gt; (RxBus.class) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (instance == &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                instance = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; RxBus();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; instance;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;注册和取消注册Bus&quot;&gt;&lt;a href=&quot;#注册和取消注册Bus&quot; class=&quot;headerlink&quot; title=&quot;注册和取消注册Bus&quot;&gt;&lt;/a&gt;注册和取消注册&lt;code&gt;Bus&lt;/code&gt;&lt;/h3&gt;&lt;p&gt;&lt;code&gt;EventBus&lt;/code&gt; 的注册过程，就是对接收某个事件的所有方法进行 &lt;code&gt;subscribe()&lt;/code&gt; ，在 &lt;code&gt;subscribe()&lt;/code&gt; 方法里拿到这些的方法，把这些方法存进 &lt;code&gt;subscriberMethods&lt;/code&gt;（一个 List 集合）中，然后把事件的类名作为 key ，把 &lt;code&gt;subscriberMethods&lt;/code&gt; 作为 value ，存进 &lt;code&gt;methodCache&lt;/code&gt;（一个 HashMap 缓存）里，这样就不用每次都去反射了。这里需要注意一点，&lt;code&gt;EventBus&lt;/code&gt; 里用 &lt;code&gt;methodCache&lt;/code&gt; cache 下来的不是 &lt;code&gt;Observer&lt;/code&gt; ，也不是 &lt;code&gt;Observable&lt;/code&gt; ，而是 &lt;code&gt;Observable.subscribe(Observer)&lt;/code&gt;，即 &lt;code&gt;Subscription&lt;/code&gt; ，那么如果用 &lt;code&gt;RxJava&lt;/code&gt; ，该怎么去实现这么个功能呢？在 RxJava 里有这样一个类 &lt;code&gt;CompositeSubscription&lt;/code&gt; ，对应的是一个存储着 &lt;code&gt;Subscription&lt;/code&gt; 的 &lt;code&gt;HashSet&lt;/code&gt;，因此我们只需要将接收事件的方法 add 进一个 &lt;code&gt;CompositeSubscription&lt;/code&gt; ，在生命周期结束的时候，再把 &lt;code&gt;CompositeSubscription&lt;/code&gt; 取消订阅即可。&lt;/p&gt;
&lt;p&gt;明确了上面的流程，对 RxJava 的封装就好办了。我们只需要获取 &lt;code&gt;Subscription&lt;/code&gt; 即可。注意，这里跟 &lt;code&gt;EventBus&lt;/code&gt; 是有区别的，&lt;code&gt;EventBus&lt;/code&gt; 的封装，是通过反射，获取所有接收事件的方法，然后注册，当然，现在的 &lt;code&gt;EventBus&lt;/code&gt; 版本里这些反射几乎对性能没有任何影响了。现在我们用 &lt;code&gt;RxJava&lt;/code&gt; 是不是也要用反射再去获取所有的 &lt;code&gt;Subscription&lt;/code&gt; 呢？当然不是，EventBus 的机制其实类似于广播，在接收事件的地方是没有方法调用的，因此需要反射。但是 &lt;code&gt;RxBus&lt;/code&gt; 则提供了调用接收事件的方法，因此只需要在 &lt;code&gt;Activity&lt;/code&gt; 或 &lt;code&gt;Fragment&lt;/code&gt; 里 new 出来 &lt;code&gt;CompositeSubscription&lt;/code&gt; 对象，然后在需要接收事件的地方，用 &lt;code&gt;CompositeSubscription&lt;/code&gt; 对象去 add 进对应的 &lt;code&gt;Subscription&lt;/code&gt; 就可以了(这一点在下面发送接收事件一节还会提到)。&lt;/p&gt;
&lt;p&gt;对应的取消注册的过程就简单多了，在生命周期结束的地方，对 &lt;code&gt;CompositeSubscription&lt;/code&gt; 取消注册即可，以避免内存泄露，而 &lt;code&gt;CompositeSubscription&lt;/code&gt; 的取消注册方法是可以自动取消 &lt;code&gt;HashSet&lt;/code&gt; 里的所有 &lt;code&gt;Subscription&lt;/code&gt; 的，因此无须对每个 &lt;code&gt;Subscription&lt;/code&gt; 单独处理。&lt;/p&gt;
&lt;h3 id=&quot;发送和接收事件&quot;&gt;&lt;a href=&quot;#发送和接收事件&quot; class=&quot;headerlink&quot; title=&quot;发送和接收事件&quot;&gt;&lt;/a&gt;发送和接收事件&lt;/h3&gt;&lt;p&gt;&lt;code&gt;EventBus&lt;/code&gt; 发送事件，就是 post 方法，在 &lt;code&gt;EventBus&lt;/code&gt; 里有一个内部类 &lt;code&gt;PostingThreadState&lt;/code&gt;， 通过 &lt;code&gt;postingState.eventQueue&lt;/code&gt; 可以获取一个 List 集合，只要 &lt;code&gt;eventQueue&lt;/code&gt; 不为空，就不断地从 &lt;code&gt;eventQueue&lt;/code&gt; 里取出事件（当然，伴随有是否为主线程，是否正在发送等状态的判断），然后调用 &lt;code&gt;postSingleEvent&lt;/code&gt; 方法，最后调 &lt;code&gt;postToSubscription&lt;/code&gt; 把事件发出去，post 一个，就从 &lt;code&gt;eventQueue&lt;/code&gt; 里 remove 一个，最终又来到了我们从刚接触 Android 就让人很头痛的 &lt;code&gt;Handler&lt;/code&gt; ，这是一个叫 &lt;code&gt;HandlerPoster&lt;/code&gt; 的类。说一千，道一万，对应的 &lt;code&gt;RxJava&lt;/code&gt; 处理事件就是调方法 &lt;code&gt;onNext&lt;/code&gt;。这样代码就有了。&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;post&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(Object object)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    subject.onNext(object);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;code&gt;EventBus&lt;/code&gt; 接收事件需要通过 &lt;code&gt;onEvent&lt;/code&gt; 开头的方法来遍历获取，第一次遍历会缓存，仅查找 &lt;code&gt;onEvent&lt;/code&gt; 开头的方法，同时忽略一些特定 SDK 的方法，可以提高一些效率。在使用 &lt;code&gt;RxJava&lt;/code&gt; 接收事件的时候，根据传递的事件类型(eventType)可以获取对应类型的 &lt;code&gt;Observable&amp;lt;EventType&amp;gt;&lt;/code&gt; ，那么问题就来了，在这里我们是不是要提供一个返回对应的 &lt;code&gt;Subscription&lt;/code&gt; 的方法呢？其实是可以的！但是需要指定 &lt;code&gt;Scheduler&lt;/code&gt; ，因为我们知道，接收事件处理事件是有可能在不同的线程里的，如果在这里我们就提供一个返回 &lt;code&gt;Subscription&lt;/code&gt; 的方法，那后续的事件处理是在哪个线程呢？因此在这里就指定了 UI 线程或者异步线程，后面的具体的事件处理就可能会有问题。当然，我们也只可以在需要接收事件的地方，调用 &lt;code&gt;toObservable&lt;/code&gt; 方法，然后指定线程。这也是相对于 &lt;code&gt;Otto&lt;/code&gt; 的一个优势。&lt;/p&gt;
&lt;p&gt;在 &lt;code&gt;RxBus&lt;/code&gt; 里：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &amp;lt;T&amp;gt; &lt;span class=&quot;function&quot;&gt;Observable&amp;lt;T&amp;gt; &lt;span class=&quot;title&quot;&gt;toObservable&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;final&lt;/span&gt; Class&amp;lt;T&amp;gt; type)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; subject.ofType(type);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &amp;lt;T&amp;gt; &lt;span class=&quot;function&quot;&gt;Subscription &lt;span class=&quot;title&quot;&gt;toSubscription&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(Class&amp;lt;T&amp;gt; type, Action1&amp;lt;T&amp;gt; action1, Scheduler scheduler)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; RxBus.getInstance()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            .toObservable(type)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            .observeOn(scheduler)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            .subscribe(action1);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;在 &lt;code&gt;Activity&lt;/code&gt; 或 &lt;code&gt;Fragment&lt;/code&gt; 里再去获取 &lt;code&gt;Subscription&lt;/code&gt; 。&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &amp;lt;T&amp;gt; &lt;span class=&quot;function&quot;&gt;Subscription &lt;span class=&quot;title&quot;&gt;toSubscription&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(Class&amp;lt;T&amp;gt; type, Action1&amp;lt;T&amp;gt; action1)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; RxBus.getInstance()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            .toObservable(type)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            .observeOn(AndroidSchedulers.mainThread())&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            .subscribe(action1);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;最后，将所有的 &lt;code&gt;Subscription&lt;/code&gt; add 进 &lt;code&gt;CompositeSubscription&lt;/code&gt; 就好了。最后，一定不要忘记对 &lt;code&gt;CompositeSubscription&lt;/code&gt; 取消注册。&lt;/p&gt;
&lt;h2 id=&quot;StickyEvent的处理&quot;&gt;&lt;a href=&quot;#StickyEvent的处理&quot; class=&quot;headerlink&quot; title=&quot;StickyEvent的处理&quot;&gt;&lt;/a&gt;&lt;code&gt;StickyEvent&lt;/code&gt;的处理&lt;/h2&gt;&lt;p&gt;到这里，有关 &lt;code&gt;EventBus&lt;/code&gt; 的内容，基本是完了，不过还有一点，&lt;code&gt;EventBus&lt;/code&gt; 里是有一个 &lt;code&gt;StickyEvent&lt;/code&gt; 的，什么意思呢，就是说一般流程是，我们先去订阅事件，然后被观察者再去发布事件，观察者去接收事件，但是如果是先发布了事件，再去订阅事件呢？这时候先于订阅事件之前发布的事件就会被丢弃，这时候 &lt;code&gt;StickyEvent&lt;/code&gt; 就登场了。即便是先于订阅事件之前发布了事件，它已然可以接收一个最近被发布的事件，可以理解为它缓存了一个最近发布的事件，而与订阅状态无关。当然，只是一个！明确了这些，要用 &lt;code&gt;RxJava&lt;/code&gt; 实现就非常简单了，在 &lt;code&gt;RxJava&lt;/code&gt; 里有一个 &lt;code&gt;BehaviorSubject&lt;/code&gt; 完美实现了这个功能，具体实现跟 &lt;code&gt;PublishSubject&lt;/code&gt; 一模一样。这时候就会有人问了，如果我们想要接收到所有的（而不是一个）在订阅事件之前发布的事件，该怎么办呢？很遗憾，&lt;code&gt;EventBus&lt;/code&gt; 是无法办到的，但是 &lt;code&gt;RxJava&lt;/code&gt; 可以！将 &lt;code&gt;BehaviorSubject&lt;/code&gt; 换成 &lt;code&gt;RelaySubject&lt;/code&gt; 即可。不过说句题外话，这样的功能好鸡肋啊，感觉适用场景少之又少。我想这也是 &lt;code&gt;EventBus&lt;/code&gt; 没有去实现这样的功能的原因吧。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;具体使用可以参照&lt;a href=&quot;https://github.com/liangzhitao/AndroidFluxPractice&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;AndroidFluxPractice&lt;/a&gt;，Sample 里将 EventBus 替换为了 RxBus ，完美地实现了一模一样的效果。&lt;/p&gt;
&lt;p&gt;参考：&lt;a href=&quot;http://www.jianshu.com/p/ca090f6e2fe2/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.jianshu.com/p/ca090f6e2fe2/&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h2&gt;&lt;p&gt;接触过 &lt;code&gt;EventBus&lt;/code&gt; 和 &lt;code&gt;RxJava&lt;/code&gt; 的都知道，可以用 &lt;code&gt;RxJava&lt;/code&gt; 来实现 &lt;code&gt;EventBus&lt;/code&gt;，网上随便一搜，就可以拿得到代码。但是究竟为什么可以这么做？却没有类似的文章作进一步的深度解析。（本文假定读者都已经了解 &lt;code&gt;EventBus&lt;/code&gt; 和 &lt;code&gt;RxJava&lt;/code&gt; 是什么，可以做什么。）
    
    </summary>
    
      <category term="Android" scheme="http://www.easydone.cn/categories/Android/"/>
    
    
      <category term="EventBus" scheme="http://www.easydone.cn/tags/EventBus/"/>
    
      <category term="RxJava" scheme="http://www.easydone.cn/tags/RxJava/"/>
    
  </entry>
  
  <entry>
    <title>给自己一个标杆</title>
    <link href="http://www.easydone.cn/2016/03/27/"/>
    <id>http://www.easydone.cn/2016/03/27/</id>
    <published>2016-03-27T14:10:26.000Z</published>
    <updated>2016-03-27T14:21:42.000Z</updated>
    
    <content type="html">&lt;blockquote&gt;
&lt;p&gt;我和我的朋友们一起在我们乡下的老家发起了一个图书馆项目，现在这个项目已经持续了三年多了。这是一篇约稿，答应同学要写写自己的经历，写的也比较随性，想到哪儿就写到哪儿。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;12年毕业之后，在一家郑州的公司，工资是2200块，扣了社保公积金，一个月到手的是1700块。因为在都市村庄住，安全性很差，又丢了钱，索性就找了个小区，房租是一个750，再加上吃饭要500块，一个月结余大概400块。房租是押一付三，第一次交房租要3000块，向同事借了2000块交了房租。也就是说，那时候连看电影，买水果都是不可想象的。因为工作的关系，要经常出差，但是只能出差回来再报销，差旅费我是向朋友借的。在我上班半年之后，欠人的钱终于还清了。跟同事的关系都处的很好，至少我感觉是这样。我在豆瓣上写下了这样的话：我希望整个职业生涯都在这里读过。然而，这时候，我被公司辞退了，至今没想通为什么。我可以毫不夸张的说，当时我的能力能秒部门里60%以上的人。&lt;/p&gt;
&lt;p&gt;然后，我又在郑州找了个工作，鉴于上份工作被辞退的经历，这份工作我做的更加努力，二月份入职，虽说是双休，但是整个三月份和四月份上半月，我一天都没休息，连着上了将近五十天的班，甚至还有几个通宵，领导很赏识我，说要给我涨500块的工资。我觉着我的付出得到了回报，我干活更加卖力。然而事与愿违，等到发工资的时候，发现并不是那么回事。我很委屈，于是我辞职了。我不想再呆在郑州了，我去了南京，到了南京几个月，天天催郑州这边的发工资，终于还是拿到工资了，虽然并没有拿到全部。我希望彻底翻过这一页，在南京重新开始。&lt;/p&gt;
&lt;p&gt;在南京，我去了软通做华为外包，经过上两份工作的经历，我已经对工作没有那么多期待，再也不会凭着一腔热情就把工作当做自己的全部。在南京的一年多时间里，我从没加过一次班。在此期间，无意中我得知了一个组织—GDG，通过GDG的介绍，我开始接触了 Android，感觉很有意思，至今仍记得南京的半坡村。因为再也没加过班，每天晚上六点之前一定会到家。就开始利用业余时间开始学习 Android 方面的东西，当然，当时并没有要把开发 Android 作为职业的想法。&lt;/p&gt;
&lt;p&gt;如果要问我工作开心吗？做一份外包工作，能有什么开心不开心的~但是真正让我下决心离开，是另外一件事。华为一张姓某女姓HR，肥的像猪一样，脸上还有一颗巨大无比的痣，是她，让我明白了一个道理：“长得丑陋的人，内心也很丑陋”。这个人的无耻，以及在郑州我自己遭受到的侮辱，成了每天晚上我在家里练习写代码到十二点以后的动力。在她第十次当着我们几个软通同事的面，用极其下作的手段和言辞歧视污蔑我们之后，我辞职了。去年十月份，我再次回到南京，那时候我的工资已经比在郑州时候涨了六倍，比在南京时候涨了三倍半，我当着张姓HR的同事的面，把她喷了一通。并不是说现在我工资多么高，不过只要比他们华为那些人高一点点我就满足了。&lt;/p&gt;
&lt;p&gt;来到北京之后，经历了半年多的9116，总算是熬出了一点成绩，个中滋味，我自己最清楚。我从来都不会把“那些无法击败你的挫折只会让你变得更强大”作为自己的签名，因为我一直都在用最不容置疑的行动去诠释它。这时候离我毕业刚好三年。“我等了三年，就是要等一个机会，我要争口气，不是想证明我了不起，而是要告诉别人我失去的东西，我一定要拿回来！”&lt;/p&gt;
&lt;p&gt;比起这些成绩，我更加庆幸，在经历这么多让自己一想起来，情绪就控制不住地变得暴戾起来的事情，自己的三观依然能够越来越正。感谢一直以来遇到的这么多的优秀的人，想要争口气的动力在从0到1的成长中会让人很受用，而从1到100的路，会有更多的荆棘，羡慕不崇拜不强求，向往憧憬优秀，又绝对的不卑不亢，摆正位置，努力做自己。这就是我的故事。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;我和我的朋友们一起在我们乡下的老家发起了一个图书馆项目，现在这个项目已经持续了三年多了。这是一篇约稿，答应同学要写写自己的经历，写的也比较随性，想到哪儿就写到哪儿。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="随笔" scheme="http://www.easydone.cn/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="经历" scheme="http://www.easydone.cn/tags/%E7%BB%8F%E5%8E%86/"/>
    
  </entry>
  
  <entry>
    <title>记一次微信朋友圈逆向</title>
    <link href="http://www.easydone.cn/2016/02/27/"/>
    <id>http://www.easydone.cn/2016/02/27/</id>
    <published>2016-02-27T00:04:30.000Z</published>
    <updated>2016-03-07T01:06:04.000Z</updated>
    
    <content type="html">&lt;p&gt;最近入了一个 apk 逆向的坑，坑深似海，不过初步算是有了一些成果，记录一下先。&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;###确定方案&lt;br&gt;刚开始想到两个方案：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;借助 Xposed ，有现成的插件可以获取数据，但是由于并无法获取朋友圈条目实体的字段，而是根据获取的部分自己去拼的实体，同时还要求 root ，armv7 的手机还不支持 Xposed 等，局限性有点大，就舍弃了该方案。在此感谢 &lt;a href=&quot;https://blog.chionlab.moe/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Chion Tang&lt;/a&gt; 同学，技术非常棒的一位大二学生，帮我提供了不少有用的信息。网上看到他的文章，然后还加了微信，又认识一位小伙伴，感觉很棒。&lt;/li&gt;
&lt;li&gt;通过查看微信的数据库缓存发现，微信的 Sqlite 里朋友圈这部分数据是没有加密的，于是就设想模拟滑动，然后不断从微信服务器拉取数据，然后缓存起来，再通过缓存取得数据。这种方案的局限显而易见，就是对于微信的存储方案并不了解，获取的数据完整性和可靠性不能保证，也就失去了其意义。&lt;/li&gt;
&lt;li&gt;在上面两种方式都遇到瓶颈的时候，我师傅小虎提供了一种思路： Android 里 Java 代码会被先编译为 smali 代码，于是就设想通过在获取服务端数据之后，显示在界面上之前，即 ListView 的 Adapter &lt;code&gt;notifyDataSetChanged&lt;/code&gt; 之前，插入我们想要执行的 smali 代码（比如获取 adapter 里 list 集合的变量，然后遍历集合，将数据存储在一个文件里，保存在 SD 卡），这样就可以获取朋友圈的数据。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;最终选择了第三种方案。假如微信没有做服务端的一些验证的话，这种方式是有可能会获取完整可靠的数据的。当然，也有不少技术难点。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;找到 &lt;code&gt;notifyDataSetChanged&lt;/code&gt; 的代码位置；&lt;/li&gt;
&lt;li&gt;APK 解包，二次打包能否正常进行；&lt;/li&gt;
&lt;li&gt;smali 语法。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;###确定插入代码位置&lt;br&gt;要确定插入代码的位置，我使用了 &lt;code&gt;jadx&lt;/code&gt; 这个工具，对 apk 进行逆向，使用 &lt;code&gt;jadx-gui&lt;/code&gt; 查看被混淆过的 java 代码，由于 Activity 及其里面的方法名是无法被混淆的，很容易就找到了具体用户的朋友圈入口，&lt;code&gt;com.tencent.mm.plugin.sns.ui.SnsUserUI&lt;/code&gt; ，然后通过关键字搜索找到了 &lt;code&gt;notifyDataSetChanged&lt;/code&gt; 所在的位置。调用这个方法的是 &lt;code&gt;SnsUserUI&lt;/code&gt; 这个类里的 aBp()方法，继承自父类 SnsActivity。最终确定了混淆后的 Adapter 类名，实体类名，以及相关的一些变量名。&lt;/p&gt;
&lt;p&gt;###验证能否正常解包和二次打包&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;正常反编译的命令是 &lt;code&gt;apktool d -o weixin wx.apk&lt;/code&gt; -o 就是 output ，将 wx.apk 反编译后输出到当前目录下的 &lt;code&gt;weixin&lt;/code&gt; 目录里。但是使用这个参数在二次打包的时候，可能会因为资源文件无法加入构建而造成打包失败。因此在解包时需要忽略资源文件，&lt;code&gt;apktool d -f -r apkfilename.apk&lt;/code&gt; &lt;code&gt;-f&lt;/code&gt; 指替换之前反编译的 apk 里代码，&lt;code&gt;-r&lt;/code&gt; 表示在反编译的时候忽略资源文件，因此二次打包就不会再遇到上述问题。（参考：&lt;a href=&quot;http://stackoverflow.com/questions/23317208/apktool-build-apk-fails&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;apktool build apk fails&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;二次打包的命令为 &lt;code&gt;apktool b wx new.apk&lt;/code&gt; ，反编译后的输出目录为 wx ，二次打包就是将 &lt;code&gt;wx&lt;/code&gt; 目录二次打包为 new.apk ，new.apk 的输出目录为 &lt;code&gt;wx&lt;/code&gt; 目录下的 &lt;code&gt;dist&lt;/code&gt; 目录。可以添加 &lt;code&gt;-o&lt;/code&gt; 指令，设置另外的 apk 输出目录。&lt;/li&gt;
&lt;li&gt;使用 debugkey 对二次打包的 apk 进行签名 &lt;code&gt;jarsigner -keystore debug.keystore -storepass android -keypass android new.apk androiddebugkey&lt;/code&gt; ，然后安装。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;至此，进入了整个流程里最困难的一个环节。&lt;/p&gt;
&lt;p&gt;###插入 smali 代码&lt;br&gt;由于对 smali 语法的一无所知，同时 smali 代码的调试也是一个大问题。（&lt;strong&gt;在此，感谢 Trinea 4群的小伙伴们的帮助，群里当真是卧虎藏龙，帮我指出了不少 smali 语法上的错误。&lt;/strong&gt;）我先学习了一下语法，大致能看明白一部分的 smali 代码，然后在 smali 里 &lt;code&gt;notifyDataSetChanged&lt;/code&gt; 之前，插入了打印日志的代码，再打包执行，没有问题！但是因为真正要插入的保存数据的代码比较复杂，自己写暂时还不太现实，最后决定先写 demo ，将要插入的代码先在 demo 里写，然后再用 apktool 解包 apk，获取插入的那一段 smali 代码，再对其修改，然后插入到 SnsUserUI.smali 里。经过一番尝试，修改了已知的语法错误后，进入具体用户的朋友圈，微信仍然是闪退…&lt;/p&gt;
&lt;p&gt;接着尝试对 smali 代码进行 debug 调试，以查看具体哪部分报错，最终找到了 smalidea 这个 IDEA 插件，官方给的教程并不详细，经过一番摸索，总结了一下，教程大致如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;下载 zip 插件包，然后安装；&lt;/li&gt;
&lt;li&gt;下载 smali.jar 和 baksmali.jar，smali 和 baksmali 脚本，然后 chmod 添加执行权限，再然后配置环境变量；&lt;/li&gt;
&lt;li&gt;使用 smali 脚本解包 apk ；&lt;/li&gt;
&lt;li&gt;将解包后的目录导入到 Android Studio，然后配置 SourceRoot 目录，再配置 SDK 和 JDK，增加远程调试选项并设置调试端口；&lt;/li&gt;
&lt;li&gt;adb install 安装apk，然后打开 ddms ，开始调试。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;最终在打开 USB 调试，选择调试应用的时候，然后发现 release 的应用都是不行的。因此只能启用 logcat 大法了。&lt;/p&gt;
&lt;p&gt;接下来只好一步步去排除可能会导致这样的结果的原因：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;然后尝试抓包，看是否有请求发送和响应，发现请求了，同时返回了200，再在无网环境下测试，依然会闪退。说明不是服务端校验的问题。至此就基本确定，是那段 smali 代码的问题。&lt;/li&gt;
&lt;li&gt;接着，我确定了另一个方向，先写一个往文件里写数据，再把文件保存在 SD 卡的方法（&lt;code&gt;writeDataToSdCard(String message)&lt;/code&gt;），然后去调这个方法，经过尝试发现 &lt;code&gt;writeDataToSdCard(&amp;quot;TESTTESTTESTTEST&amp;quot;)&lt;/code&gt; ，直接写字符串也是不行的（后来发现还是因为寄存器用的不对，最简单的一种解决方式就是方法名用 static 修饰）。&lt;/li&gt;
&lt;li&gt;此路不通，只好再用打印日志的方式，由于之前已经测试单纯地打印字符串日志是没问题的，这时候只要 for 循环 adapter 里的 list ，然后打印就可以了。当然，要先打印一条数据试试看这个 list 的获取是否正确，&lt;code&gt;Log.i(TAG, list.get(0).toString());&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;结果依然不行，logcat 里报了 &lt;code&gt;Verifier rejected&lt;/code&gt; &lt;code&gt;SnsUserUI is not the default one&lt;/code&gt; 的错误，目测是 Android 的一些验证失败了。所以这也并不能证明是获取的 list 的问题。&lt;/li&gt;
&lt;li&gt;接下来将 &lt;code&gt;forEach&lt;/code&gt; 循环换成了 &lt;code&gt;for(int i = 0; i &amp;lt; adapter.getCount(); i++)&lt;/code&gt; 的形式，然后打印输出 &lt;code&gt;adapter.getItem(i).toString()&lt;/code&gt; ，如此就避免了直接操作 list 的问题，因此就排除了4里提到的获取 list 错误的问题，但是结果在 logcat 里仍然出现了4中的错误。&lt;/li&gt;
&lt;li&gt;再次无路可走，这时候我师傅小虎又出马了，提醒我可以把5里面的 for 循环抽出来成静态方法，其实抽取方法以保证寄存器等不受影响，我在上面已经用过了，但是这时候思维已经钻进死胡同了，没有想到这一步。于是，按照师傅的指点，果然，大功告成了。还是插入的 smali 代码有问题，而且还发现之前找的 &lt;code&gt;notifyDataSetChanged&lt;/code&gt; 的入口是有问题的。&lt;/li&gt;
&lt;li&gt;最后就是从 Java 代码里找入口，确定字段的体力活了。不过，一眼看去，密密麻麻朋友圈实体里有几十上百个字段，还各种父类继承，Map，linkedList，一堆一堆的，这体力活真的好大…&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;至此，大致过程就 OK 了。顺带提一句，掌握一些基本的 shell，awk，sed 等终端语法命令还是很有必要的，会省下不少的繁复的工作量。当然，这也只是我自己执行的过程，别人做的时候，很可能会避开一些没有必要的坑。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;最近入了一个 apk 逆向的坑，坑深似海，不过初步算是有了一些成果，记录一下先。
    
    </summary>
    
      <category term="Android" scheme="http://www.easydone.cn/categories/Android/"/>
    
    
      <category term="APK逆向" scheme="http://www.easydone.cn/tags/APK%E9%80%86%E5%90%91/"/>
    
      <category term="apktool" scheme="http://www.easydone.cn/tags/apktool/"/>
    
      <category term="smali" scheme="http://www.easydone.cn/tags/smali/"/>
    
  </entry>
  
</feed>
